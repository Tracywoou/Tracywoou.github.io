<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tracywoo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tracywoo.cn/"/>
  <updated>2021-07-29T03:29:53.066Z</updated>
  <id>http://tracywoo.cn/</id>
  
  <author>
    <name>Tracy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率图模型CMU-Lecture1-概率图模型简介</title>
    <link href="http://tracywoo.cn/2021/07/29/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8BCMU-Lecture1-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/"/>
    <id>http://tracywoo.cn/2021/07/29/%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8BCMU-Lecture1-%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B/</id>
    <published>2021-07-29T02:06:25.000Z</published>
    <updated>2021-07-29T03:29:53.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PGM-lecture1-简介"><a href="#PGM-lecture1-简介" class="headerlink" title="PGM lecture1 简介"></a>PGM lecture1 简介</h1><h2 id="统计基础"><a href="#统计基础" class="headerlink" title="统计基础"></a>统计基础</h2><p>对于多变量<script type="math/tex">(X_1, X_2,X_3,X_4,X_5,X_6,X_7,X_8)</script>，假设<script type="math/tex">x_i \in \{0,1\}</script>，很自然的，可以把联合分布概率表示为：</p><div class="table-container"><table><thead><tr><th><script type="math/tex">x_1</script></th><th><script type="math/tex">x_2</script></th><th><script type="math/tex">x_3</script></th><th><script type="math/tex">x_4</script></th><th><script type="math/tex">x_5</script></th><th><script type="math/tex">x_6</script></th><th><script type="math/tex">x_7</script></th><th><script type="math/tex">x_8</script></th><th><script type="math/tex">p</script></th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0.2</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><p>此时行数是确定的，即<script type="math/tex">2^8</script>行，这是一个枚举的方法，但是要求我们的数据集需要有足够大的规模，那么才能把每一种可能情况的概率计算出来。</p><script type="math/tex; mode=display">X$$和$$Y$$可能存在的关系有相关、独立、依赖、因果。“Many of them can be measured by **one number summary**”## 变量关系的度量方法#### 皮尔森相关(Pearson's correlation)皮尔森相关系数：</script><p>\begin{array}{l}<br>\rho (X,Y) = \frac{ { Cov(X,Y) } } { { \sqrt { Var(X)} \sqrt { Var(Y) } } }\\<br>{ \mathop{ \rm cov}} (X,Y) = E((X - \mu )(Y - \upsilon ))\\<br>{ \mathop{ \rm cov} } (X,Y) = E(X \cdot Y) - \mu \upsilon<br>\end{array}</p><script type="math/tex; mode=display">变量之间的线性相关，从$$X$$到$$Y$$的线性回归：$$\beta  = \frac{ { Cov(X,Y) } } { { Var(X) } }$$属性：相关系数的大小直接决定了线性相关性的高低；但是只能刻画线性相关关系；不能断定因果关系。$$X,Y$$独立，则$$\rho (X,Y) = 0$$，而$$\rho (X,Y) = 0$$不能推出$$X,Y$$独立。反例：$$y=x^2,x \in [-1,1]$$，该函数是非线性的。#### 互信息(Mutual information)计算两个分布之间的距离，可以用**KL散度**(Kullback-Leibler divergence)（讨论：reverse KL）$$\begin{array}{l}KL(P,Q) = \int\limits_{x \in X} {P(x)\log \frac{{P(x)}}{{Q(x)}}dx}\end{array}$$**互信息**：计算两种特殊情况的差异。</script><p>I(X,Y) = KL({P_{XY}},{P_X}{P_Y})</p><script type="math/tex; mode=display">当且仅当$$I(X,Y)=0$$时，$$X$$和$$Y$$相互独立。#### 希尔伯特-施密特独立性准则#### (Hilbert-Schmidt Independence Criterion, HSIC)主要目的是衡量**两个变量的分布差异**，这一点类似于协方差（方差），而对于其本身也是依赖于协方差而构建。</script><p>HSIC(X,Y) = MMD({P_{XY}},{P_X}{P_Y})\\<br>MMD(P,Q) = \parallel {\mu _k}(P) - {\mu _k}(Q){\parallel _}\\<br>{\mu _k}(P) = {E_{Z-P}}[\phi (Z)]</p><script type="math/tex; mode=display">$$P$$的kernal embedding$$\phi (Z)$$ 核$$k$$的特征图当且仅当$$HSIC(X,Y)=0$$时，$$X$$和$$Y$$相互独立。#### 偏相关(Partial correlation)举例：构造一个图模型$$X=$$孩子的身高$$Y=$$孩子的词汇量$$Z=$$孩子的年龄我们会发现我们会在变量之间两两构造联系，但是按照我们的经验构造的图将会是孩子的年龄决定身高和词汇量，这才是可解释的。以上介绍的方法都只能得到前者而不能得到后者，是因为他们只考虑了一对变量之间的联合概率分布。偏相关就是计算给定随机向量$$Z$$时$$X$$和$$Y$$之间的偏相关。</script><p>\begin{array}{l}<br>\rho (X,Y|Z) = \frac{ {Cov({e_X},{e_Y})} }{ {\sqrt {Var({e_X})} \sqrt {Var({e_Y})} } }\\<br>{e_X} = X - (\beta _X^TZ + {\rm{int}}ercep{t_X})\\<br>{e_Y} = X - (\beta _Y^TZ + {\rm{int}}ercep{t_Y})<br>\end{array}</p><p>$$<br>实质是一个给定条件的皮尔森相关系数。</p><p>如果假设每个维度变量都是高斯分布的，可以简化计算。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="//tracywoo.cn/2021/07/29/概率图模型CMU-Lecture1-概率图模型简介/blog\source\_posts\概率图模型CMU-Lecture1-概率图模型简介\image-20210126162056714.png" alt="image-20210126162056714"></p><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><h4 id="Lecture-2-条件独立图"><a href="#Lecture-2-条件独立图" class="headerlink" title="Lecture 2 条件独立图"></a>Lecture 2 条件独立图</h4><p>别名：条件独立图，马尔可夫网，马尔可夫随机场，无向图。</p><p>应用：模拟围棋。</p><h4 id="Lecture-3-有向图模型"><a href="#Lecture-3-有向图模型" class="headerlink" title="Lecture 3 有向图模型"></a>Lecture 3 有向图模型</h4><p>别名：有向图、有向无环图、贝叶斯网络、</p><p>Structural equation models、Structural casual models</p><p>应用：家族的族谱。</p><h4 id="Lecture-4-13-推理学习"><a href="#Lecture-4-13-推理学习" class="headerlink" title="Lecture 4-13 推理学习"></a>Lecture 4-13 推理学习</h4><p>推理：边缘/条件分布、采样</p><p>学习：统计参数估计、模型选择</p><h4 id="Lecture-5-end-现有的图模型"><a href="#Lecture-5-end-现有的图模型" class="headerlink" title="Lecture 5-end 现有的图模型"></a>Lecture 5-end 现有的图模型</h4><p>DL和图模型的关系、深度生成模型、强化学习做概率推理、无参数贝叶斯网络、大规模算法和系统</p><h2 id="图模型是什么"><a href="#图模型是什么" class="headerlink" title="图模型是什么"></a>图模型是什么</h2><p>一种用于交流(domain knowledge)、计算和发展的语言。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;PGM-lecture1-简介&quot;&gt;&lt;a href=&quot;#PGM-lecture1-简介&quot; class=&quot;headerlink&quot; title=&quot;PGM lecture1 简介&quot;&gt;&lt;/a&gt;PGM lecture1 简介&lt;/h1&gt;&lt;h2 id=&quot;统计基础&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="PGM" scheme="http://tracywoo.cn/tags/PGM/"/>
    
  </entry>
  
  <entry>
    <title>如何在word中打出好看的公式</title>
    <link href="http://tracywoo.cn/2021/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8word%E4%B8%AD%E6%89%93%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%85%AC%E5%BC%8F/"/>
    <id>http://tracywoo.cn/2021/07/29/%E5%A6%82%E4%BD%95%E5%9C%A8word%E4%B8%AD%E6%89%93%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%85%AC%E5%BC%8F/</id>
    <published>2021-07-29T01:03:54.000Z</published>
    <updated>2021-07-29T01:56:32.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在word中打出好看的公式"><a href="#如何在word中打出好看的公式" class="headerlink" title="如何在word中打出好看的公式"></a>如何在word中打出好看的公式</h1><p>通常我们编辑公式通常都是使用MathType，但是在将Mathtype中的公式对象粘贴到Word的时候，就会发现文字不对齐的情况，最近在将Latex格式的公式写到word里，总结了一下在word中粘贴Latex公式代码的方法，特此记录。</p><p>在Word中其实是有自带的编辑器的，按快捷键<code>ALT + =</code>就可以进入公式的输入模式：</p><p><img src="//tracywoo.cn/2021/07/29/如何在word中打出好看的公式/blog\source\_posts\如何在word中打出好看的公式\输入公式.png" alt="输入公式"></p><p>按快捷键<code>CTRL + i</code>就可以进入斜体模式。</p><p>按<code>CTRL + =</code>就可以将Latex公式进行编译得到公式。</p><p>word默认的公式字体是Cambria Math，这种字体不如Latex的好看。</p><p>因此可以安装字体Latin Modern Math，按照<a href="https://github.com/LittleNewton/Replace_MathType#13-latexlivecom-%E7%BD%91%E7%AB%99-进行操作。" target="_blank" rel="noopener">https://github.com/LittleNewton/Replace_MathType#13-latexlivecom-%E7%BD%91%E7%AB%99-进行操作。</a></p><p>对于Word中的公式默认字体，可以通过公式的设计中进行设置。</p><p><img src="//tracywoo.cn/2021/07/29/如何在word中打出好看的公式/blog\source\_posts\如何在word中打出好看的公式\design.jpg" alt="设计"></p><p><img src="//tracywoo.cn/2021/07/29/如何在word中打出好看的公式/blog\source\_posts\如何在word中打出好看的公式\set.jpg" alt="set"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何在word中打出好看的公式&quot;&gt;&lt;a href=&quot;#如何在word中打出好看的公式&quot; class=&quot;headerlink&quot; title=&quot;如何在word中打出好看的公式&quot;&gt;&lt;/a&gt;如何在word中打出好看的公式&lt;/h1&gt;&lt;p&gt;通常我们编辑公式通常都是使用Math
      
    
    </summary>
    
    
    
      <category term="写论文小技巧" scheme="http://tracywoo.cn/tags/%E5%86%99%E8%AE%BA%E6%96%87%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>python提取记事本文件中的数字绘制数字变化曲线</title>
    <link href="http://tracywoo.cn/2021/06/07/%E6%8F%90%E5%8F%96%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%98%E5%88%B6%E6%95%B0%E5%AD%97%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF/"/>
    <id>http://tracywoo.cn/2021/06/07/%E6%8F%90%E5%8F%96%E8%AE%B0%E4%BA%8B%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%98%E5%88%B6%E6%95%B0%E5%AD%97%E5%8F%98%E5%8C%96%E6%9B%B2%E7%BA%BF/</id>
    <published>2021-06-07T10:38:16.000Z</published>
    <updated>2021-06-07T14:27:08.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python读取记事本文件"><a href="#python读取记事本文件" class="headerlink" title="python读取记事本文件"></a>python读取记事本文件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filename = <span class="string">"D:\\OneDrive\\code\\aba\\output\\alarm\\v5\\sample10000_gen500_pop100_K2_0\\info.txt"</span></span><br><span class="line">f = open(filename, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">  ...: <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  ...:     line = f.readline()</span><br><span class="line">  ...:     <span class="keyword">if</span> line:</span><br><span class="line">  ...:         <span class="keyword">print</span> (line)</span><br><span class="line">  ...:     <span class="keyword">else</span>:</span><br><span class="line">  ...:         <span class="keyword">break</span></span><br><span class="line">  ...: f.close()</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"gen 70: best score: -106886.61585569178, min sparsity: , true score: -106445.6497111178"</span></span><br><span class="line">all_score = re.findall(<span class="string">r"-\d+\.?\d*"</span>,string)</span><br><span class="line">x_gen = float(all_score[<span class="number">0</span>])</span><br><span class="line">true_score = float(all_score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;python读取记事本文件&quot;&gt;&lt;a href=&quot;#python读取记事本文件&quot; class=&quot;headerlink&quot; title=&quot;python读取记事本文件&quot;&gt;&lt;/a&gt;python读取记事本文件&lt;/h1&gt;&lt;figure class=&quot;highlight pyth
      
    
    </summary>
    
    
    
      <category term="others" scheme="http://tracywoo.cn/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>Git&amp;Githubub_eeerinzhang bilibili</title>
    <link href="http://tracywoo.cn/2020/07/13/Git-Githubub-eeerinzhang-bilibili/"/>
    <id>http://tracywoo.cn/2020/07/13/Git-Githubub-eeerinzhang-bilibili/</id>
    <published>2020-07-13T06:57:01.000Z</published>
    <updated>2020-07-13T12:28:44.881Z</updated>
    
    <content type="html"><![CDATA[<p>Git: Version control system</p><p>让不同的人在不同的地点在不同的时间线编辑file，可以有不同的Branch，通过Merge把大家的file合并。</p><p>Github: Software/ Tool for Git</p><p>Repository/ Git project: 保存文件夹所有的编辑历史。</p><p>Commit: 类似于文件的截图。</p><p>Branch: Master branch, Master branch的分支。</p><h1 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h1><p>git主页下载Git软件。下载完成后，输入<code>git --version</code>，若出现版本则安装成功。</p><p>Initialize  a git repository, <code>git init</code></p><p>配置user name, user email</p><p><img src="//tracywoo.cn/2020/07/13/Git-Githubub-eeerinzhang-bilibili/git1.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Git: Version control system&lt;/p&gt;
&lt;p&gt;让不同的人在不同的地点在不同的时间线编辑file，可以有不同的Branch，通过Merge把大家的file合并。&lt;/p&gt;
&lt;p&gt;Github: Software/ Tool for Git&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GAN_生成对抗网络</title>
    <link href="http://tracywoo.cn/2020/07/12/GAN-%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://tracywoo.cn/2020/07/12/GAN-%E7%94%9F%E6%88%90%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-12T01:09:07.000Z</published>
    <updated>2020-07-12T06:26:40.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GAN的基本思想"><a href="#GAN的基本思想" class="headerlink" title="GAN的基本思想"></a>GAN的基本思想</h1><p>图像生成：向量-&gt;图像。</p><p>条件生成：控制输出图像的类型。</p><p><strong>Generator：</strong> 向量-&gt;生成器-&gt;图像</p><p><strong>Discriminator：</strong>图像-&gt;判别器-&gt;分数</p><p>在GAN的训练过程中，通过生成器和判别器的拮抗作用进行物竞天择。</p><p><img src="//tracywoo.cn/2020/07/12/GAN-生成对抗网络/basic.png" alt="bi" style="zoom:67%;"></p><p>可以把生成器比做成学生，判别器作为老师，学生给老师交作业，通过老师的修改和反馈不断修改自己的作业，直到交出一份完美的答卷。</p><p>算法：</p><p><img src="//tracywoo.cn/2020/07/12/GAN-生成对抗网络/al2.png" alt="al" style="zoom:67%;"></p><p>在每次迭代中，从数据库中采样一些样本。</p><p>s1: 固定生成器G，更新判别器D；</p><p>s2: 固定判别器D，更新生成器G。</p><p>生成器需要学着去愚弄判别器。</p><p><img src="//tracywoo.cn/2020/07/12/GAN-生成对抗网络/AL3.png" alt="AL" style="zoom:67%;"></p><p>可以把GAN看成结构学习算法，结构学习中的数据往往不是一个简单的数值，如在机器翻译中得到的结果是一段话，在图像生成中得到的结果是一张图像。往往得到的结果都是未出现过的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;GAN的基本思想&quot;&gt;&lt;a href=&quot;#GAN的基本思想&quot; class=&quot;headerlink&quot; title=&quot;GAN的基本思想&quot;&gt;&lt;/a&gt;GAN的基本思想&lt;/h1&gt;&lt;p&gt;图像生成：向量-&amp;gt;图像。&lt;/p&gt;
&lt;p&gt;条件生成：控制输出图像的类型。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="ML" scheme="http://tracywoo.cn/categories/ML/"/>
    
    
  </entry>
  
  <entry>
    <title>MOEA测试函数</title>
    <link href="http://tracywoo.cn/2020/07/12/MOEA%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/"/>
    <id>http://tracywoo.cn/2020/07/12/MOEA%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-12T00:34:57.000Z</published>
    <updated>2020-07-12T01:00:31.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MOEA测试的基本问题"><a href="#MOEA测试的基本问题" class="headerlink" title="MOEA测试的基本问题"></a>MOEA测试的基本问题</h1><blockquote><p><strong>MOEA测试的具体内容</strong></p><p>多目标优化问题的一个测试函数或者一组测试函数，或一个实际应用问题可以构成对MOEA的测试。</p><p><strong>如何找到合适的MOEA测试函数</strong></p><p>从已知的MOEA文献或者他人提出和总结的构造测试函数的方法，或者为人熟知的实际问题中找到一个合适的MOEA测试。</p><p><strong>何时对MOEA进行测试</strong></p><p>在MOEA设计与实现的过程不断地对它进行测试，也可以在一个MOEA完全实现后再对它进行测试</p></blockquote><h1 id="选择MOP时需要考虑的特征"><a href="#选择MOP时需要考虑的特征" class="headerlink" title="选择MOP时需要考虑的特征"></a>选择MOP时需要考虑的特征</h1><ol><li>连续的或非连续的或离散的；</li><li>可导的或不可导的；</li><li>凸的或凹的；</li><li>函数的形态（单峰的，多峰的）；</li><li>数值函数或包含字母与数字的函数；</li><li>二次方的或非二次方的；</li><li>约束条件的类型（等式、不等式、线性的、非线性的）；</li><li>低维的或高维的（基因型、表现型）；</li><li>欺骗问题或非欺骗问题；</li><li>相对真实PF时候有偏好。</li></ol><h1 id="常见的测试函数集"><a href="#常见的测试函数集" class="headerlink" title="常见的测试函数集"></a>常见的测试函数集</h1><h2 id="ZDT"><a href="#ZDT" class="headerlink" title="ZDT"></a>ZDT</h2><p><img src="//tracywoo.cn/2020/07/12/MOEA测试函数/ZDT.png" alt="ZDT"></p><p>其他的测试函数还有DTLZ和WGF系列。（填坑）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MOEA测试的基本问题&quot;&gt;&lt;a href=&quot;#MOEA测试的基本问题&quot; class=&quot;headerlink&quot; title=&quot;MOEA测试的基本问题&quot;&gt;&lt;/a&gt;MOEA测试的基本问题&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MOEA测试的具体内容&lt;/
      
    
    </summary>
    
    
      <category term="MOEA" scheme="http://tracywoo.cn/categories/MOEA/"/>
    
    
  </entry>
  
  <entry>
    <title>Archer主题扩展使用</title>
    <link href="http://tracywoo.cn/2020/07/12/Archer%E4%B8%BB%E9%A2%98%E6%89%A9%E5%B1%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://tracywoo.cn/2020/07/12/Archer%E4%B8%BB%E9%A2%98%E6%89%A9%E5%B1%95%E4%BD%BF%E7%94%A8/</id>
    <published>2020-07-12T00:16:27.000Z</published>
    <updated>2020-07-12T00:29:49.282Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自定义文章页头图"><a href="#自定义文章页头图" class="headerlink" title="自定义文章页头图"></a>自定义文章页头图</h1><p>通过配置每篇文章(即.md文件)的头部的<code>header_image</code>字段来修改，如果不填写将采用主题配置中的<code>post_header_image</code>字段，如果<code>post_header_image</code>字段未填写则采用<code>site_header_image</code>字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line">date: 2013-12-24 23:29:53</span><br><span class="line">tags:</span><br><span class="line">- Foo</span><br><span class="line">- Bar</span><br><span class="line">- Baz</span><br><span class="line">header_image: /intro/post-bg.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="将-Unsplash-随机图片作为头图"><a href="#将-Unsplash-随机图片作为头图" class="headerlink" title="将 Unsplash 随机图片作为头图"></a>将 Unsplash 随机图片作为头图</h1><p>API 参数页面：<a href="https://source.unsplash.com/" target="_blank" rel="noopener">https://source.unsplash.com/</a></p><p>在 archer 的配置文件中将头图设为上面的 API 提供的 URL，可以设置图片大小和范围等等，也可以使用自己的 Unsplash 的账户收藏的图片等等，这样每次访问时将会随机加载不同的头图。</p><h1 id="切换代码配色方案"><a href="#切换代码配色方案" class="headerlink" title="切换代码配色方案"></a>切换代码配色方案</h1><p>主题现在有两套代码配色：atom-one-dark 及 atom-one-light（v1.5.0 开始默认 atom-one-dark）。 配色取自 <a href="https://highlightjs.org/static/demo/" target="_blank" rel="noopener">hightlight</a></p><h2 id="切换方法"><a href="#切换方法" class="headerlink" title="切换方法"></a>切换方法</h2><ol><li>修改 <code>archer\source-src\scss\_variables.scss</code> 中的 <code>$code-theme</code>，可以更换为 <code>atom-one-dark</code> 或 <code>atom-one-light</code>。</li><li>在 archer 目录下执行 <code>npm install</code>，然后执行 <code>npm run build</code>。</li><li>再重新执行 <code>hexo g</code> 即可。</li></ol><h1 id="解决Hexo文章置顶功能"><a href="#解决Hexo文章置顶功能" class="headerlink" title="解决Hexo文章置顶功能"></a>解决Hexo文章置顶功能</h1><p><a href="https://www.jianshu.com/p/42a4efcdf8d7" target="_blank" rel="noopener">文章置顶功能</a></p><h1 id="设置文章版权信息"><a href="#设置文章版权信息" class="headerlink" title="设置文章版权信息"></a>设置文章版权信息</h1><p>修改主题配置文件中的 copyright 字段开启/关闭：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  # https://creativecommons.org/</span><br><span class="line">  license: &apos;本文采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc/4.0/&quot;&gt;知识共享署名-非商业性使用 4.0 国际许可协议&lt;/a&gt;进行许可&apos;</span><br></pre></td></tr></table></figure><p>默认显示作者，链接，日期以及版权说明，版权说明可通过 copyright.lincese 自定义。</p><p><strong>copyright.lincese 的值可以是 HTML</strong></p><p>当文章版权信息开启时，可通过文章 Markdown 头部：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyright: false</span><br></pre></td></tr></table></figure><p>进行单篇文章版权信息的关闭。</p><hr><p>special thanks to <a href="https://github.com/ahonn/hexo-theme-even/wiki/设置文章版权信息" target="_blank" rel="noopener">hexo-theme-even</a>，这部分说明直接我是直接抄过来的..</p><h1 id="启用-Algolia-搜索"><a href="#启用-Algolia-搜索" class="headerlink" title="启用 Algolia 搜索"></a>启用 Algolia 搜索</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有几种方案可选：</p><ol><li>选用 <code>hexo-content-json</code> 类的 hexo 插件，生成一个包含所有文章内容的 xml 或 json，这样的好处是配置步骤少，但是会下载一个 json 或 xml，体积与所有文章的内容成正比，如果文章数量较多的话要下载的体积就会比较大，文章数量少的话又没啥必要。</li><li>选用 <code>hexo-content-json</code> 类的 hexo 插件，生成一个只包含文章题目的 xml 或 json，这样文件的体积会小很多，hexo-theme-yilia 是采用的这种方案，并且将 <code>#</code> 搜索 tag 的功能也加上了，但是 archer 已经有了 tag 分类，这样做就仅仅是搜索题目了，用处也不大。</li><li>选用第三方的搜索，具有搜索所有文章内容的功能，也是目前 hexo 主题届的老大 hexo-theme-next 采用的方案，最后选定了这种。</li></ol><p>PS: 感谢 Algolia &amp; hexo-theme-next</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="注册帐号-可以用-Github-登录"><a href="#注册帐号-可以用-Github-登录" class="headerlink" title="注册帐号(可以用 Github 登录)"></a>注册帐号(可以用 Github 登录)</h3><p>前往 Algolia <a href="https://www.algolia.com/" target="_blank" rel="noopener">注册页面</a>，注册一个新账户。 可以使用 GitHub 或者 Google 账户直接登录，注册后的 14 天内拥有所有功能（包括收费类别的）。之后若未续费会自动降级为免费账户，免费账户 总共有 10,000 条记录，每月有 100,000 的可以操作数。注册完成后，创建一个新的 Index，这个 Index 将在后面使用。</p><p><img src="https://user-images.githubusercontent.com/12322740/40921716-d512bae6-6842-11e8-804e-53a8e71206ab.png" alt="image"></p><h3 id="安装-Algolia"><a href="#安装-Algolia" class="headerlink" title="安装 Algolia"></a>安装 Algolia</h3><p>Index 创建完成后，此时这个 Index 里未包含任何数据。 接下来需要安装 <a href="https://github.com/oncletom/hexo-algolia" target="_blank" rel="noopener">Hexo Algolia</a> 扩展， 这个扩展的功能是搜集站点的内容并通过 API 发送给 Algolia。前往站点根目录，执行命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><h3 id="获取-keys"><a href="#获取-keys" class="headerlink" title="获取 keys"></a>获取 keys</h3><p>在 Algolia 服务站点上找到需要使用的一些配置的值，包括 ApplicationID、Search-Only API Key、 Admin API Key。注意，Admin API Key 需要保密保存。点击ALL API KEYS 找到新建INDEX对应的key， 编辑权限，在弹出框中找到ACL选择勾选Add records, Delete records, List indices, Delete index权限，点击update更新。</p><h1 id="启用-Latex-支持"><a href="#启用-Latex-支持" class="headerlink" title="启用 Latex 支持"></a>启用 Latex 支持</h1><p>事实上启用对 Latex 的支持是 Hexo 的一项功能，而与 archer 无关。 可以参照这两篇文章来开启对 Latex 的支持：</p><ol><li><a href="https://nathaniel.blog/tutorials/make-hexo-support-math-again/" target="_blank" rel="noopener">Make Hexo Support Math Again</a></li><li><a href="http://2wildkids.com/2016/10/06/如何处理Hexo和MathJax的兼容问题/#小结" target="_blank" rel="noopener">如何处理Hexo和MathJax的兼容问题</a></li></ol><h1 id="英文界面"><a href="#英文界面" class="headerlink" title="英文界面"></a>英文界面</h1><p>将 Hexo 配置中的 <code>language</code> 修改为 <code>language: en</code> 即可切换为英文界面。 暂时只支持英文，其他会默认中文。</p><p>也可自行修改 <code>language</code> 文件夹下的 <code>en.yml</code> 来自定义英文界面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;自定义文章页头图&quot;&gt;&lt;a href=&quot;#自定义文章页头图&quot; class=&quot;headerlink&quot; title=&quot;自定义文章页头图&quot;&gt;&lt;/a&gt;自定义文章页头图&lt;/h1&gt;&lt;p&gt;通过配置每篇文章(即.md文件)的头部的&lt;code&gt;header_image&lt;/code&gt;字
      
    
    </summary>
    
    
      <category term="博客" scheme="http://tracywoo.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>platEMO_多目标优化工具箱</title>
    <link href="http://tracywoo.cn/2020/07/10/platEMO-%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AE%B1/"/>
    <id>http://tracywoo.cn/2020/07/10/platEMO-%E5%A4%9A%E7%9B%AE%E6%A0%87%E4%BC%98%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AE%B1/</id>
    <published>2020-07-10T13:14:11.000Z</published>
    <updated>2020-07-11T02:43:11.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>platEMO是Ye Tian等学者写的一款基于MATLAB的多目标优化工具。</p><p>这款工具主要具有以下的几个特点：<br>1.完全由MATLAB开发，不需要任何其它库。<br>2.用户可以显示各种图形，包括结果的pareto front，真实的pareto front等等。<br>3.强大友好的GUI，可以不用编辑任何代码，直接调用主函数main.m即可。<br>4.可以直接生成Excel或者LaTex。</p><h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p><a href="https://github.com/BIMK/PlatEMO" target="_blank" rel="noopener">github</a></p><p>该平台使用的详细信息可以在platEMO中的manual.pdf中读取。</p><p><a href="http://bimk.ahu.edu.cn/index.php?s=/Index/Software/index.html" target="_blank" rel="noopener">实验室主页</a> </p><p>下载后，将matlab运行目录设置为该文件夹即可。</p><h1 id="文件夹结构"><a href="#文件夹结构" class="headerlink" title="文件夹结构"></a>文件夹结构</h1><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/文件.png" alt="文件夹"></p><p><strong>Algorithm：</strong></p><p>包括现有的90个流行的MOEAs，包括遗传算法、差分进化、粒子群优化、模因算法、分布估计算法和基于代理模型的算法。其中大多数是2010年以后在顶级期刊上发表的代表性算法。</p><p><strong>Data：</strong></p><p>包括120多个benchmark MOPs。</p><p><strong>GUI：</strong></p><p>用于存储平台界面的源代码。</p><p><strong>Metrics：</strong></p><p>用于存储所有性能指标的源代码。</p><p><strong>Operators:</strong></p><p>用于存储所有算子的源代码。</p><p><strong>Problems:</strong></p><p>用于存储所有多目标优化问题的源代码。</p><p><strong>Public:</strong></p><p>用于存储所有类和实例的函数。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="命令行使用platEMO"><a href="#命令行使用platEMO" class="headerlink" title="命令行使用platEMO"></a>命令行使用platEMO</h2><p>用户可以通过调用带有输入参数的接口函数main（）来运行PlatEMO的命令模式。</p><p>如果main（）在没有任何输入参数的情况下被调用，则GUI模式将运行。</p><p>下表列出了main（）的所有可接受参数。注意，用户不需要分配所有参数，因为每个参数都有一个默认值。</p><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/parameter.png" alt="参数"></p><p><strong>-algorithm.</strong> 要执行的MOEA的函数。<br><strong>-problem.</strong> 待解决的MOP。<br><strong>-N.</strong> MOEA的种群规模。注意，它被固定在某些MOEAs(例如moead .m)中的某些特定值上，因此这些MOEAs的实际种群大小可能并不完全等于这个参数。<br><strong>-M.</strong> MOP的目标数目。注意，在不可伸缩的MOPs(例如ZDT1.m)中，目标的数量是恒定的，因此这个参数对于这些MOPs是无效的。<br><strong>-D.</strong> MOP决策变量的个数。注意，在某些MOP中，决策变量的数量是常量或固定到某些特定整数上的(例如：ZDT5.m)，因此决策变量的实际数量可能并不完全等于这个参数。<br><strong>-evaluation.</strong> 函数评价的最大数目。<br><strong>-run.</strong> 运行数。如果用户希望为相同的算法、问题、M和D参数保存多个结果，则在每次运行时修改此参数，使结果的文件名不同。<br><strong>-save.</strong> 保存的种群。如果将该参数设置为0(默认值)，则会在终止后显示结果图;否则，在进化过程中获得的种群将保存在一个名为Data\algorithm\algorithm_problem_M_D_run.mat的文件中。例如：如果save为5并且evaluation是20000，评价数量为4000、8000、12000、16000、20000时得到的种群将被保存。<br><strong>-outputFcn.</strong> 每次生成后调用的函数，通常不需要修改。</p><p>例如：使用下面的命令在WFG1上运行RVEA，其种群大小为200和10个目标，最终结果将显示出来：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="string">'-algorithm'</span>,@RVEA,<span class="string">'-problem'</span>,@WFG1,<span class="string">'-N'</span>,<span class="number">200</span>,<span class="string">'-M'</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>使用以下命令在WFG2上运行KnEA，并在KnEA和WFG2中设置参数:</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="string">'-algorithm'</span>,&#123;@KnEA,<span class="number">0.4</span>&#125;,<span class="string">'-problem'</span>,&#123;@WFG2,<span class="number">6</span>&#125;);</span><br></pre></td></tr></table></figure><p>每个MOEA和MOP的具体参数可以在对应函数头部的注释中找到。使用以下命令在DTLZ5上运行AR-MOEA10次，最终保存种群：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> r = <span class="number">1</span> : <span class="number">10</span></span><br><span class="line">     main(<span class="string">'-algorithm'</span>,@ARMOEA,<span class="string">'-problem'</span>,@DTLZ5,<span class="string">'-save'</span>,<span class="number">1</span>, <span class="string">'-run'</span>,r);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="使用带GUI的platEMO"><a href="#使用带GUI的platEMO" class="headerlink" title="使用带GUI的platEMO"></a>使用带GUI的platEMO</h2><p>用户可以通过以下命令运行PlatEMO的GUI模式：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main();</span><br></pre></td></tr></table></figure><p>然后在GUI上可以看到两个模块，即测试模块和实验模块。测试模块用于每次在MOP上执行一个MOEA，结果将以图的形式显示。实验模块将同时在几个MOPs上执行多个MOEAs。统计结果将列在表格中。</p><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/STRU.png" alt="结构"></p><p>A: 选择执行的算法和多目标优化问题。</p><p>B: 设置所选MOEA和MOP的参数。每个参数的值应该是一个标量。注意这里的公共参数N,M,D和evaluation都视为MOP的参数。如果将参数设置为空，则该参数将等于其默认值。</p><p>C: 根据当前配置执行MOEA。</p><p>D: 显示光标移动到的区域B中的参数的介绍。</p><p>E: 显示优化过程中的当前种群。</p><p>F: 放大，缩小，平移或旋转E区域的轴。</p><p>G: 在新的标准MATLAB图中打开E区域的坐标轴，可以对坐标轴进行更多的操作，例如保存坐标轴。</p><p>H: 选择要显示在E区域轴线上的数据，包含种群的pareto front，种群的pareto集合，MOP的真实pareto front和任何性能度量的收敛轮廓。</p><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/K.png" alt="H" style="zoom:50%;"></p><p>I: 控制优化过程，即，开始，暂停，停止，后退和前进。<br>J: 显示其中一个历史结果。<br>K: 显示结果的最终种群的性能度量值。<br>L: 显示执行的详细信息。<br>用户打开测试模块后，首先选择要在A区域执行的MOEA和MOP，并在B区域设置参数，然后按下区域C按钮执行算法。实时种群将显示在E区域的轴线上，用户可以使用I区域的按钮来控制优化过程。算法结束后，通过选择J区域的弹出菜单，可以重新显示所有的历史结果。</p><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/TEST.png" alt="TEST"></p><p>PlatEMO实验模块界面如上图所示。各区域管制的职能如下：<br>Region A. 选择要执行的MOEA和MOP。<br>Region B.设置所选MOEA和MOP的参数。MOPs里的每个参数的值都可以是一个向量。因此，MOEAs可以在相同的MOP上以不同的设置执行。<br>Region C.设置每个文件中保存的种群数量。例如，如果种群大小为5，评估的数量为20000，评价数量为4000，8000，12000，16000和20000时的种群被保存。<br>Region D.设置每个MOP上每个MOEA的运行次数。<br>Region E.设置保存实验设置的文件路径。用户还可以打开现有的配置文件来加载实验设置。所有结果都将保存在文件路径的同一文件夹中。<br>Region F.按顺序或并行执行实验。<br>Region G.显示实验的统计结果。<br>Region H.指定表中显示的数据类型。<br>Region I.将表格保存为Excel或LaTeX格式。<br>Region J.选择表中显示的数据，包括最终总体的任何性能度量值。<br>Region K.控制优化过程，即，开始，暂停，停止。<br>Region L.右键单击一个单元格，以显示种群的Pareto front，种群的pareto集合，或度量值的收敛轮廓。</p><p>用户打开实验模块后，首先选择在区域A中执行的MOEAs和MOPs，并在区域B中设置它们的参数，在区域C中设置保存的种群数量，在区域D中设置运行的数量。然后按下F区域的两个按钮中的一个开始实验。统计结果将显示在G区域的表格中，用户可以使用K区域的按钮来控制优化过程。实验结束后，按下I区按钮，可以将表中数据以Excel或LaTeX格式保存。<br>或者，用户可以通过按区域K中的按钮加载现有配置，然后开始实验。如果在E区域给定的文件夹中已经存在任何结果文件，则将加载结果文件，而不是执行算法。</p><h1 id="扩展platEMO"><a href="#扩展platEMO" class="headerlink" title="扩展platEMO"></a>扩展platEMO</h1><h2 id="platEMO的结构"><a href="#platEMO的结构" class="headerlink" title="platEMO的结构"></a>platEMO的结构</h2><p><img src="//tracywoo.cn/2020/07/10/platEMO-多目标优化工具箱/arch.png" alt="结构"></p><p>进行platEMO平台的实现的三个类是：GLOBAL, INDIVIDUAL和PROBLEMS。其中每个算法都是一个函数，ALGORITHM不是一个类，而是所有算法函数的统一接口。</p><p>GLOBAL表示当前运行的配置，其源代码和详细注释可在Public\GLOBAL.m中找到。在每次执行,维护一个GLOBAL对象来存储所有的参数设置和结果,包括执行的函数处理MOEA和MOP,种群规模,目标的数量,数量的决策变量,函数的最大数量评估,评估个体的数量,等等。GLOBAL还提供了一些MOEAs可以调用的方法，例如，GLOBAL.Initialization()可以生成一个随机的种群初始化，并且GLOBAL.NotTermination()可以检查是否应该终止算法。<br>INDIVIDUAL代表一个个体，源代码及其详细注释可以在Public\INDIVIDUAL.m中找到。一个INDIVIDUAL目标储存决策变量dec、目标值obj、约束违反con和一个个体的附加属性值。在调用构造函数时分配dec和add的值，然后自动计算obj和con的值。上面的每一个性质都是一个行向量，p.decs，P.objs, P.cons或P.adds表示一个决策变量的矩阵，分别为目标值、违反约束或单个INDIVIDUAL对象P数组的附加属性值，其中矩阵的每一行表示一个个体，每一列表示值的一维。当实例化的INDIVIDUAL对象数量超过函数GLOBAL.evaluation计算的最大数量时，算法将被迫终止。<br>PROBLEM是所有问题类的超类。它包含几个方法，即，PROBLEM.Init()用于生成初始种群，PROBLEM.CalDec()用于修复不可行的决策变量，PROBLEM.CalObj()用于计算目标值，PROBLEM.CalCon()用于计算约束违反情况，以及PROBLEM.PF()用于在真正的帕累托前沿采样参考点。每个问题都应该作为PROBLEM的子类来编写，并重载上面的方法。</p><h2 id="增加算法"><a href="#增加算法" class="headerlink" title="增加算法"></a>增加算法</h2><p>MOEA函数由PlatEMO中的一个.m文件表示，该文件应放在“算法”文件夹中。例如，NSGAII.m的源代码是</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NSGAII</span><span class="params">(Global)</span> </span></span><br><span class="line">  Population = Global.Initialization(); </span><br><span class="line">  [~,FrontNo,CrowdDis] = EnvironmentalSelection(Population,Global.N); </span><br><span class="line">  <span class="keyword">while</span> Global.NotTermination(Population) </span><br><span class="line">      MatingPool = TournamentSelection(<span class="number">2</span>,Global.N,FrontNo, -CrowdDis); </span><br><span class="line">      Offspring = GA(Population(MatingPool)); </span><br><span class="line">      [Population,FrontNo,CrowdDis] = EnvironmentalSelection([Population,Offspring], Global.N); </span><br><span class="line">  <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先，用全局变量进行初始化，生成一个初始种群。</p><p>一个多目标进化算法至少有三步：通过Global.Initialization()全局初始化，通过 Global.NotTermination()检查优化是否结束，通过算子（例如GA()）得到子代，EnvironmentalSelection() 是NSGAⅡ特有的算法，  NDSort() 和<br>TournamentSelection()是存储在Public中的实例函数。</p><p>对于基于分解的MOEAs，需要预先生成一组参考点。例如，在MOEAD.m中，使用以下命令生成参考点：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[W,Global.N] = UniformPoint(Global.N,Global.M);</span><br></pre></td></tr></table></figure><p>其中UniformPoint（）是Public文件夹中的一个实例函数，用于在单元超平面上生成具有Global.M目标的Global.N均匀分布点。W是参考点集，总体规模全局。N重置为W中参考点的数量。</p><p>MOEA函数（以及MOP函数）头部应该以指定的形式编写，以便GUI能够识别。例如，在gfmmea.m中，函数头中的注释是</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GFMMOEA</span><span class="params">(Global)</span> </span></span><br><span class="line"><span class="comment">% &lt;algorithm&gt; &lt;G&gt; </span></span><br><span class="line"><span class="comment">% Generic front modeling based MOEA </span></span><br><span class="line"><span class="comment">% theta --- 0.2 --- Penalty parameter </span></span><br><span class="line"><span class="comment">% fPFE  --- 0.1 --- Frequency of generic front modeling</span></span><br></pre></td></tr></table></figure><p>第2行给出了函数的两个标签，第一个标签\<algorithm>表示这是一个MOEA函数（\<problem> 和 \<metric> 分别表示多目标优化问题和指标）。第二个标签\<g>可以是任意字符串。第3行给出了MOEA的全名。第4-5行是GFM-MOEA的参数，其中参数的名称位于每一行的第一列。默认值位于第二列，简介位于第三列；这些列用“-”分隔。然后，GFM-MOEA通过以下命令接收用户的参数设置：</g></metric></problem></algorithm></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[theta,fPFE] = Global.ParameterSet(<span class="number">0.2</span>,<span class="number">0.1</span>);</span><br></pre></td></tr></table></figure><p>可以在Public\GLOBAL.m中找到Global.ParameterSet()的详细介绍。对于代理辅助的MOEA，可以使用以下命令根据父母的决策变量生成新的决策变量，没有INDIVIDUAL对象会被实例化，并且被评估的个体的数量GLOBAL.evaluated不会增加。</p><p><code>OffDec = GA(Population(MatingPool).decs);</code></p><p>对于函数GA（），如果输入是INDIVIDUAL 对象的数组，则输出也是INDIVIDUAL 对象的数组。如果输入是决策变量的矩阵，那么输出也是决策变量的矩阵。</p><h2 id="增加问题"><a href="#增加问题" class="headerlink" title="增加问题"></a>增加问题</h2><p>MOP函数由PlatEMO中的一个.m文件表示，该文件应该放在文件夹Problems中。<br>例如，DTLZ2的源代码.m是</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">classdef</span> DTLZ2 &lt; PROBLEM</span><br><span class="line"><span class="number">2.</span>     <span class="keyword">methods</span></span><br><span class="line"><span class="number">3.</span>         <span class="function"><span class="keyword">function</span> <span class="title">obj</span> = <span class="title">DTLZ2</span><span class="params">()</span></span></span><br><span class="line"><span class="number">4.</span>             <span class="keyword">if</span> <span class="built_in">isempty</span>(obj.Global.M)</span><br><span class="line"><span class="number">5.</span>                 obj.Global.M = <span class="number">3</span>;</span><br><span class="line"><span class="number">6.</span>             <span class="keyword">end</span></span><br><span class="line"><span class="number">7.</span>             <span class="keyword">if</span> <span class="built_in">isempty</span>(obj.Global.D)</span><br><span class="line"><span class="number">8.</span>                 obj.Global.D = obj.Global.M + <span class="number">9</span>;</span><br><span class="line"><span class="number">9.</span>             <span class="keyword">end</span></span><br><span class="line"><span class="number">10.</span>            obj.Global.lower = <span class="built_in">zeros</span>(<span class="number">1</span>,obj.Global.D);</span><br><span class="line"><span class="number">11.</span>            obj.Global.upper = <span class="built_in">ones</span>(<span class="number">1</span>,obj.Global.D);</span><br><span class="line"><span class="number">12.</span>            obj.Global.encoding = <span class="string">'real'</span>;</span><br><span class="line"><span class="number">13.</span>         <span class="keyword">end</span></span><br><span class="line"><span class="number">14.</span>         <span class="function"><span class="keyword">function</span> <span class="title">PopObj</span> = <span class="title">CalObj</span><span class="params">(obj,PopDec)</span></span></span><br><span class="line"><span class="number">15.</span>             M = obj.Global.M;</span><br><span class="line"><span class="number">16.</span>             g = sum((PopDec(:,M:<span class="keyword">end</span>)<span class="number">-0.5</span>).^<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="number">17.</span>             PopObj = <span class="built_in">repmat</span>(<span class="number">1</span>+g,<span class="number">1</span>,M).*<span class="built_in">fliplr</span>(cumprod([<span class="built_in">ones</span> (<span class="built_in">size</span>(g,<span class="number">1</span>),<span class="number">1</span>),<span class="built_in">cos</span>(PopDec(:,<span class="number">1</span>:M1)*<span class="built_in">pi</span>/<span class="number">2</span>)],<span class="number">2</span>)).[<span class="built_in">ones</span>(<span class="built_in">size</span>(g,<span class="number">1</span>),<span class="number">1</span>),<span class="built_in">sin</span>(PopDec(:,M<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">1</span>)*<span class="built_in">pi</span>/<span class="number">2</span>)];</span><br><span class="line"><span class="number">18.</span>         <span class="keyword">end</span></span><br><span class="line"><span class="number">19.</span>         <span class="function"><span class="keyword">function</span> <span class="title">P</span> = <span class="title">PF</span><span class="params">(obj,N)</span></span></span><br><span class="line"><span class="number">20.</span>             P = UniformPoint(N,obj.Global.M);</span><br><span class="line"><span class="number">21.</span>             P = P./<span class="built_in">repmat</span>(<span class="built_in">sqrt</span>(sum(P.^<span class="number">2</span>,<span class="number">2</span>)),<span class="number">1</span>,obj.Global.M);</span><br><span class="line"><span class="number">22.</span>         <span class="keyword">end</span></span><br><span class="line"><span class="number">23.</span>     <span class="keyword">end</span></span><br><span class="line"><span class="number">24.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>首先，DTLZ2是问题的子类，每个操作都是一个重载方法。在DTLZ2.DTLZ2()构造函数中设置目标个数的值GLOBAL.M，决策变量的数量GLOBAL.D，决策变量的下界GLOBAL.lower，决策变量的上界GLOBAL.upper，和编码GLOBAL.encoding。在DTLZ2.CalObj()中，计算种群的目标值。在DTLZ2.PF()中，真实的帕累托前沿选取一组参考点。</p><p>值得注意的是，决策变量在三种情况下可能是不可行的。首先，对于连续MOPs，它可能大于全局上界（GLOBAL.upper）或小于下界（GLOBAL.lower）。在这种情况下，它将被INDIVIDUAL的类设置为边界值，而MOP类不需要处理这种情况。其次，它可能没有满足约束(一个正的约束违背表明这个约束没有被满足)，在这种情况下，约束违背应该通过重载方法PROBLEM.CalCon()来计算，例如在C1_DTLZ1.m中：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">PopCon</span> = <span class="title">CalCon</span><span class="params">(obj,PopDec)</span></span></span><br><span class="line"><span class="number">2.</span>     PopObj = obj.CalObj(PopDec);</span><br><span class="line"><span class="number">3.</span>     PopCon = PopObj(:,<span class="keyword">end</span>)/<span class="number">0.6</span>+sum(PopObj(:,<span class="number">1</span>:<span class="keyword">end</span><span class="number">-1</span>)/<span class="number">0.5</span>,<span class="number">2</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="number">4.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第三，对于组合MOPs，它可能是一个非法字符，在这种情况下，它应该通过重载方法PROBLEM.CalDec()来修复，例如在MOKP.m中：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">PopDec</span> = <span class="title">CalDec</span><span class="params">(obj,PopDec)</span></span></span><br><span class="line"><span class="number">2.</span>     C = sum(obj.W,<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="number">3.</span>     [~,rank] = <span class="built_in">sort</span>(<span class="built_in">max</span>(obj.P./obj.W));</span><br><span class="line"><span class="number">4.</span>     <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(PopDec,<span class="number">1</span>)</span><br><span class="line"><span class="number">5.</span>         <span class="keyword">while</span> any(obj.W*PopDec(<span class="built_in">i</span>,:)’&gt;C)</span><br><span class="line"><span class="number">6.</span>             k = <span class="built_in">find</span>(PopDec(<span class="built_in">i</span>,rank),<span class="number">1</span>);</span><br><span class="line"><span class="number">7.</span>             PopDec(<span class="built_in">i</span>,rank(k)) = <span class="number">0</span>;</span><br><span class="line"><span class="number">8.</span>         <span class="keyword">end</span></span><br><span class="line"><span class="number">9.</span>     <span class="keyword">end</span></span><br><span class="line"><span class="number">10.</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>与MOEA函数类似，MOP类可以接收用户的参数设置，例如在WFG1.m中，以下命令用于接收参数设置：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> obj.K = obj.Global.ParameterSet(obj.Global.M<span class="number">-1</span>);</span><br></pre></td></tr></table></figure><h2 id="增加性能度量"><a href="#增加性能度量" class="headerlink" title="增加性能度量"></a>增加性能度量</h2><p>性能度量函数由PlatEMO中的.m文件表示，该文件应该放在Metrics文件夹中。例如，IGD.m的源代码是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function"><span class="keyword">function</span> <span class="title">score</span> = <span class="title">IGD</span>(<span class="params">PopObj,PF</span>)</span></span><br><span class="line">2. % &lt;metric&gt; &lt;min&gt;</span><br><span class="line"><span class="number">3.</span>     score = mean(min(pdist2(PF,PopObj),[],<span class="number">2</span>);</span><br><span class="line"><span class="number">4.</span> end</span><br></pre></td></tr></table></figure><p>首先，性能度量函数有两个输入参数和一个输出参数，其中PopObj表示种群目标值矩阵，PF表示在真实Pareto前沿采样的一组参考点，并且score表示性能度量值。注意，第2行中的注释是GUI标识所必需的，其中第一个标签表示这是一个性能度量函数，第二个标签表示度量值越小性能越好。相反，如果第二个标签是，则表示度量值越大，性能越好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;platEMO是Ye Tian等学者写的一款基于MATLAB的多目标优化工具。&lt;/p&gt;
&lt;p&gt;这款工具主要具有以下的几个特点：&lt;br&gt;1.完
      
    
    </summary>
    
    
    
      <category term="MOEA" scheme="http://tracywoo.cn/tags/MOEA/"/>
    
  </entry>
  
  <entry>
    <title>VAE_变分自编码器</title>
    <link href="http://tracywoo.cn/2020/07/10/VAE-%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"/>
    <id>http://tracywoo.cn/2020/07/10/VAE-%E5%8F%98%E5%88%86%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/</id>
    <published>2020-07-10T05:51:25.000Z</published>
    <updated>2020-07-11T02:37:27.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>VAE(Variational Auto-Encoder，VAE)是一种生成网络。</p><p>假如我们有一个带有解卷积层的网络，我们设置输入为值全为1的向量，输出为一张图像。然后，我们可以训练这个网络去减小重构图像和原始图像的平均平方误差。那么训练完后，这个图像的信息就被保留在了网络的参数中。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/3.png" alt="带有解卷积层的网络"></p><p>这次我们用one-hot向量而不是全1向量。我们用[1, 0, 0, 0]代表猫，用[0, 1, 0, 0]代表狗。虽然这要没什么问题，但是我们最多只能储存4张图片。当然，我们也可以增加向量的长度和网络的参数，那么我们可以获得更多的图片。</p><p>但是，这样的向量很稀疏。为了解决这个问题，我们想使用实数值向量而不是0，1向量。我们可认为这种实数值向量是原图片的一种编码，这也就引出了编码/解码的概念。举个例子，[3.3, 4.5, 2.1, 9.8]代表猫，[3.4, 2.1, 6.7, 4.2] 代表狗。这个已知的初始向量可以作为我们的潜在变量。</p><p>使用随机初始化来代表图片并不是一个好的手段，我们希望计算机能够帮我们实现自动编码。在Auto-Encoder模型中，我们加入了一个编码器，它能够帮助我们把图片编码程向量，然后解码器能够把这些向量恢复成图片。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/4.png" alt="带有编码器和解卷积层的网络"></p><p>此时获得的网络是标准自编码器，能够将图片的编码向量进行存储，从而进行重构。</p><p>若对于编码器添加约束，强迫它产生服从单位高斯分布的潜在变量。这就是VAE不同于标准自编码器的地方。现在，产生新的图片也变得容易：我们只要从单位高斯分布中进行采样，然后把它传给解码器就可以了。</p><p>对于我们的损失函数，我们可以把这两方面进行加和。一方面，是图片的重构误差，我们可以用平均平方误差来度量，另一方面。我们可以用KL散度来度量我们潜在变量的分布和单位高斯分布的差异。</p><blockquote><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/8.png" alt="loss"></p><p>KL散度可以求两个分布间的距离，KL越小，分布距离越近，即越相似。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/5.png" alt="loss"></p></blockquote><p>VAE的编码器会产生两个向量:一个是均值向量，一个是标准差向量。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/6.png" alt="ms"></p><p>我们可以这样来计算KL散度：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># z_mean and z_stddev are two vectors generated by encoder network</span><br></pre></td></tr></table></figure><blockquote><p>latent_loss = 0.5 * tf.reduce_sum(tf.square(z_mean) + tf.square(z_stddev) - tf.log(tf.square(z_stddev)) - 1,1)</p></blockquote><p>当我们计算解码器的loss时，我们就可以从标准差向量中采样，然后加到我们的均值向量上，就得到了编码去需要的潜在变量。</p><blockquote><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/7.png" alt="la"></p></blockquote><p>VAE除了能让我们能够自己产生随机的潜在变量，这种约束也能提高网络的产生图片的能力。</p><p>为了更加形象，我们可以认为潜在变量是一种数据的转换。</p><p>使用VAE好处就是可以通过编码解码的步骤，直接比较重建图片和原始图片的差异，但是GAN做不到。</p><p> 另外，VAE的一个劣势就是没有使用对抗网络，所以会更趋向于产生模糊的图片。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/8.jpeg" alt="ex"></p><p>p(X|Z) 就描述了一个由 Z 来生成 X 的模型，而我们假设 Z 服从标准正态分布，也就是 p(Z)=N(0,I)。<strong>如果这个理想能实现，那么我们就可以先从标准正态分布中采样一个 Z，然后根据 Z 来算一个 X，也是一个很棒的生成模型</strong>。</p><p>接下来就是结合自编码器来实现重构，保证有效信息没有丢失，再加上一系列的推导，最后把模型实现。框架的示意图如下：</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/9.jpeg" alt="ms2"></p><p>其实，<strong>在整个 VAE 模型中，我们并没有去使用 p(Z)（先验分布）是正态分布的假设，我们用的是假设 p(Z|X)（后验分布）是正态分布</strong>。</p><p>具体来说，给定一个真实样本 Xk，我们假设存在<strong>一个专属于 Xk 的分布 p(Z|Xk)</strong>（学名叫后验分布），并进一步假设这个分布是（独立的、多元的）正态分布。</p><p>为什么要强调“专属”呢？因为我们后面要训练一个生成器 X=g(Z)，希望能够把从分布 p(Z|Xk) 采样出来的一个 Zk 还原为 Xk。</p><p>如果假设 p(Z) 是正态分布，然后从 p(Z) 中采样一个 Z，那么我们怎么知道这个 Z 对应于哪个真实的 X 呢？<strong>现在 p(Z|Xk) 专属于 Xk，我们有理由说从这个分布采样出来的 Z 应该要还原到 Xk 中去</strong>。</p><p>论文 Auto-Encoding Variational Bayes的应用部分，也特别强调了这一点：</p><blockquote><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/10.png" alt="for"></p></blockquote><p><strong>那我怎么找出专属于 Xk 的正态分布 p(Z|Xk) 的均值和方差呢？</strong>好像并没有什么直接的思路。</p><p>那好吧，<strong>我就用神经网络来拟合出来</strong>。</p><p>于是我们构建两个神经网络 μk=f1(Xk)，logσ^2=f2(Xk) 来算它们了。我们选择拟合 logσ^2 而不是直接拟合 σ^2，是因为 σ^2 总是非负的，需要加激活函数处理，而拟合 logσ^2 不需要加激活函数，因为它可正可负。</p><p>到这里，我能知道专属于 Xk 的均值和方差了，也就知道它的正态分布长什么样了，然后从这个专属分布中采样一个 Zk 出来，然后经过一个生成器得到 X̂k=g(Zk)。</p><p>现在我们可以放心地最小化 D(X̂k,Xk)^2，因为 Zk 是从专属 Xk 的分布中采样出来的，这个生成器应该要把开始的 Xk 还原回来。<strong>于是可以画出 VAE 的示意图：</strong></p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/11.jpeg" alt="for2"></p><p>事实上，VAE 是为每个样本构造专属的正态分布，然后采样来重构。</p><p>让我们来思考一下，根据上图的训练过程，最终会得到什么结果。</p><p>首先，我们希望重构 X，也就是最小化 D(X̂k,Xk)^2，但是这个重构过程受到噪声的影响，因为 Zk 是通过重新采样过的，不是直接由 encoder 算出来的。</p><p>显然噪声会增加重构的难度，不过好在这个噪声强度（也就是方差）通过一个神经网络算出来的，所以最终模型为了重构得更好，肯定会想尽办法让方差为0。</p><p>而方差为 0 的话，也就没有随机性了，所以不管怎么采样其实都只是得到确定的结果（也就是均值），只拟合一个当然比拟合多个要容易，而均值是通过另外一个神经网络算出来的。</p><p>说白了，<strong>模型会慢慢退化成普通的 AutoEncoder，噪声不再起作用</strong>。</p><p>这样不就白费力气了吗？说好的生成模型呢？</p><p>别急别急，<strong>VAE 还让所有的 p(Z|X) 都向标准正态分布看齐</strong>，这样就防止了噪声为零，同时保证了模型具有生成能力。</p><p>如果所有的 p(Z|X) 都很接近标准正态分布 N(0,I)，那么根据定义：</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/13.png" alt="for3"></p><p>这样我们就能达到我们的先验假设：p(Z) 是标准正态分布。然后我们就可以放心地从 N(0,I) 中采样来生成图像了。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/14.jpeg" alt="for2"></p><p>在VAE中使用了重参数的技巧(Reparameterization Trick)</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/15.png" alt="for2"></p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/16.png" alt="for2"></p><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>VAE 虽然也称是 AE（AutoEncoder）的一种，但它的做法（或者说它对网络的诠释）是别具一格的。</p><p>在 VAE 中，它的 Encoder 有两个，一个用来计算均值，一个用来计算方差。</p><p><strong>它本质上就是在我们常规的自编码器的基础上，对 encoder 的结果（在VAE中对应着计算均值的网络）加上了“高斯噪声”，使得结果 decoder 能够对噪声有鲁棒性；而那个额外的 KL loss（目的是让均值为 0，方差为 1），事实上就是相当于对 encoder 的一个正则项，希望 encoder 出来的东西均有零均值。</strong></p><p>那另外一个 encoder（对应着计算方差的网络）的作用呢？它是用来<strong>动态调节噪声的强度</strong>的。</p><p>直觉上来想，<strong>当 decoder 还没有训练好时（重构误差远大于 KL loss），就会适当降低噪声（KL loss 增加），使得拟合起来容易一些（重构误差开始下降）</strong>。</p><p>反之，<strong>如果 decoder 训练得还不错时（重构误差小于 KL loss），这时候噪声就会增加（KL loss 减少），使得拟合更加困难了（重构误差又开始增加），这时候 decoder 就要想办法提高它的生成能力了</strong>。</p><p><img src="//tracywoo.cn/2020/07/10/VAE-变分自编码器/17.jpeg" alt="for2"></p><p><strong>重构的过程是希望没噪声的，而 KL loss 则希望有高斯噪声的，两者是对立的。所以，VAE 跟 GAN 一样，内部其实是包含了一个对抗的过程，只不过它们两者是混合起来，共同进化的</strong>。</p><p><strong>在 VAE 中，重构跟噪声是相互对抗的，重构误差跟噪声强度是两个相互对抗的指标，而在改变噪声强度时原则上需要有保持均值不变的能力，不然我们很难确定重构误差增大了，究竟是均值变化了（encoder的锅）还是方差变大了（噪声的锅）</strong>。</p><p>参考资料：</p><p><a href="https://www.sohu.com/a/226209674_500659" target="_blank" rel="noopener">变分自编码器VAE：原来是这么一回事 | 附开源代码</a></p><p><a href="https://www.jeremyjordan.me/variational-autoencoders/" target="_blank" rel="noopener">VAE</a></p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>附上在tensorflow上实现VAE的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># x_hat, n_hidden, dim_z, keep_prob</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_MLP_encoder</span><span class="params">(x, n_hidden, n_output, keep_prob)</span>:</span></span><br><span class="line">    <span class="comment"># Gaussian MLP as encoder 构造编码器</span></span><br><span class="line">    <span class="comment"># input: x(输入数据), n_hidden(隐藏层个数), n_output(输出层个数), keep_prob()</span></span><br><span class="line">    <span class="comment"># output: mean(均值) ,stddev(方差)</span></span><br><span class="line">    print(<span class="string">"encode:\n"</span>)</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"gaussian_MLP_encoder"</span>):</span><br><span class="line">        <span class="comment"># 初始化 w b</span></span><br><span class="line">        <span class="comment"># scale=1.0,mode="fan_in",distribution="normal",seed=None，dtype=dtypes.float32</span></span><br><span class="line">        w_init = tf.contrib.layers.variance_scaling_initializer()</span><br><span class="line">        b_init = tf.constant_initializer(<span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1st hidden layer</span></span><br><span class="line">        w0 = tf.get_variable(<span class="string">'w0'</span>, [x.get_shape()[<span class="number">1</span>], n_hidden], initializer=w_init)</span><br><span class="line">        b0 = tf.get_variable(<span class="string">'b0'</span>, [n_hidden], initializer=b_init)</span><br><span class="line">        h0 = tf.matmul(x, w0) + b0</span><br><span class="line">        <span class="comment"># elu为激活函数 &lt;0 exp(x)-1  &gt;0 =x</span></span><br><span class="line">        h0 = tf.nn.elu(h0)</span><br><span class="line">        h0 = tf.nn.dropout(h0, keep_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2nd hidden layer 隐含层函数</span></span><br><span class="line">        w1 = tf.get_variable(<span class="string">'w1'</span>, [h0.get_shape()[<span class="number">1</span>], n_hidden], initializer=w_init)</span><br><span class="line">        b1 = tf.get_variable(<span class="string">'b1'</span>, [n_hidden], initializer=b_init)</span><br><span class="line">        h1 = tf.matmul(h0, w1) + b1</span><br><span class="line">        h1 = tf.nn.tanh(h1)</span><br><span class="line">        h1 = tf.nn.dropout(h1, keep_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># output layer 输出层</span></span><br><span class="line">        wo = tf.get_variable(<span class="string">'wo'</span>, [h1.get_shape()[<span class="number">1</span>], n_output * <span class="number">2</span>], initializer=w_init)</span><br><span class="line">        bo = tf.get_variable(<span class="string">'bo'</span>, [n_output * <span class="number">2</span>], initializer=b_init)</span><br><span class="line">        gaussian_params = tf.matmul(h1, wo) + bo</span><br><span class="line"></span><br><span class="line">        <span class="comment"># The mean parameter is unconstrained</span></span><br><span class="line">        mean = gaussian_params[:, :n_output]</span><br><span class="line">        <span class="comment"># The standard deviation must be positive. Parametrize with a softplus and</span></span><br><span class="line">        <span class="comment"># add a small epsilon for numerical stability</span></span><br><span class="line">        stddev = <span class="number">1e-6</span> + tf.nn.softplus(gaussian_params[:, n_output:])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mean, stddev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bernoulli_MLP_decoder</span><span class="params">(z, n_hidden, n_output, keep_prob, reuse=False)</span>:</span></span><br><span class="line">    <span class="comment"># Bernoulli MLP as decoder</span></span><br><span class="line">    <span class="comment"># input: z(隐变量), n_hidden(隐藏层个数),n_output(输出个数), keep_prob(), reuse()</span></span><br><span class="line">    print(<span class="string">"decode"</span>)</span><br><span class="line">    <span class="keyword">with</span> tf.variable_scope(<span class="string">"bernoulli_MLP_decoder"</span>, reuse=reuse):</span><br><span class="line">        <span class="comment"># initializers</span></span><br><span class="line">        w_init = tf.contrib.layers.variance_scaling_initializer()</span><br><span class="line">        b_init = tf.constant_initializer(<span class="number">0.</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1st hidden layer</span></span><br><span class="line">        w0 = tf.get_variable(<span class="string">'w0'</span>, [z.get_shape()[<span class="number">1</span>], n_hidden], initializer=w_init)</span><br><span class="line">        b0 = tf.get_variable(<span class="string">'b0'</span>, [n_hidden], initializer=b_init)</span><br><span class="line">        h0 = tf.matmul(z, w0) + b0</span><br><span class="line">        h0 = tf.nn.tanh(h0)</span><br><span class="line">        h0 = tf.nn.dropout(h0, keep_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2nd hidden layer</span></span><br><span class="line">        w1 = tf.get_variable(<span class="string">'w1'</span>, [h0.get_shape()[<span class="number">1</span>], n_hidden], initializer=w_init)</span><br><span class="line">        b1 = tf.get_variable(<span class="string">'b1'</span>, [n_hidden], initializer=b_init)</span><br><span class="line">        h1 = tf.matmul(h0, w1) + b1</span><br><span class="line">        h1 = tf.nn.elu(h1)</span><br><span class="line">        h1 = tf.nn.dropout(h1, keep_prob)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># output layer-mean</span></span><br><span class="line">        wo = tf.get_variable(<span class="string">'wo'</span>, [h1.get_shape()[<span class="number">1</span>], n_output], initializer=w_init)</span><br><span class="line">        bo = tf.get_variable(<span class="string">'bo'</span>, [n_output], initializer=b_init)</span><br><span class="line">        y = tf.sigmoid(tf.matmul(h1, wo) + bo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoencoder</span><span class="params">(x_hat, x, dim_img, dim_z, n_hidden, keep_prob)</span>:</span></span><br><span class="line">    <span class="comment"># input: x_hat(input), x(), dim_img(284**2), dim_z(-&gt; n_output), n_hidden(500), keep_prob(0.9 dropout)</span></span><br><span class="line">    <span class="comment"># encodingGateway</span></span><br><span class="line">    <span class="comment"># 编码得到方差和均值</span></span><br><span class="line">    mu, sigma = gaussian_MLP_encoder(x_hat, n_hidden, dim_z, keep_prob)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 得到</span></span><br><span class="line">    <span class="comment"># sampling by re-parameterization technique</span></span><br><span class="line">    z = mu + sigma * tf.random_normal(tf.shape(mu), <span class="number">0</span>, <span class="number">1</span>, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># decoding</span></span><br><span class="line">    y = bernoulli_MLP_decoder(z, n_hidden, dim_img, keep_prob)</span><br><span class="line">    <span class="comment"># 对数据的限制 y&lt;1e-8 则y=1e-8 y&gt;1-1e-8 则y=1-1e-8 否则y=原值</span></span><br><span class="line">    y = tf.clip_by_value(y, <span class="number">1e-8</span>, <span class="number">1</span> - <span class="number">1e-8</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># loss</span></span><br><span class="line">    marginal_likelihood = tf.reduce_sum(x * tf.log(y) + (<span class="number">1</span> - x) * tf.log(<span class="number">1</span> - y), <span class="number">1</span>)</span><br><span class="line">    KL_divergence = <span class="number">0.5</span> * tf.reduce_sum(tf.square(mu) + tf.square(sigma) - tf.log(<span class="number">1e-8</span> + tf.square(sigma)) - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算张量沿着指定的数轴上的平均值 用于降维或者计算tensor的平均值</span></span><br><span class="line">    marginal_likelihood = tf.reduce_mean(marginal_likelihood)</span><br><span class="line">    KL_divergence = tf.reduce_mean(KL_divergence)</span><br><span class="line"></span><br><span class="line">    ELBO = marginal_likelihood - KL_divergence</span><br><span class="line"></span><br><span class="line">    loss = -ELBO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y, z, loss, -marginal_likelihood, KL_divergence</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decoder</span><span class="params">(z, dim_img, n_hidden)</span>:</span></span><br><span class="line">    y = bernoulli_MLP_decoder(z, n_hidden, dim_img, <span class="number">1.0</span>, reuse=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;VAE(Variational Auto-Encoder，VAE)是一种生成网络。&lt;/p&gt;
&lt;p&gt;假如我们有一个带有解卷积层的网络，我们设置
      
    
    </summary>
    
    
    
      <category term="ML" scheme="http://tracywoo.cn/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>博客的重新配置</title>
    <link href="http://tracywoo.cn/2020/07/10/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/"/>
    <id>http://tracywoo.cn/2020/07/10/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-10T00:38:08.000Z</published>
    <updated>2020-07-12T00:06:31.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>换了电脑以后一直没有鼓起勇气重新安装各种软件（怕麻烦本人哈哈哈），阿里云的email提醒我域名该续费了，续完费发现自己又把之前的操作什么的忘得一干二净=-=，于是又开始配置。痛定思痛，以后要好好写博客记录自己的所学所想哈哈哈哈，奥里给，冲鸭！</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如何将之前的博客部署到新的电脑上？"><a href="#如何将之前的博客部署到新的电脑上？" class="headerlink" title="如何将之前的博客部署到新的电脑上？"></a>如何将之前的博客部署到新的电脑上？</h2><p>我是把之前的与博客的相关文件直接复制到新电脑上，重新安装了Git和Node.js，但是此时进入blog文件夹进行hexo部署时一直报错：</p><p><code>Please make sure you have the correct access rights and the repository exist</code></p><p><code>The authenticity of host &#39;github.com (xx.xxx.xxx.xxx)&#39; can&#39;t be established.</code></p><p><code>unable to auto-detect email address (got &#39;11647@LAPTOP-2902H8OD.(none)&#39;)</code></p><p>查了各方的资料，一直报错，但是大致知道是因为SSH密钥和电脑的连接出现了问题。最后问题的解决大致流程如下：</p><p>进入系统的SSH文件夹，使用 <code>git bash</code> 设置用户名和邮箱（我不知道是不是和要github中的一致，但是我一开始设置不一致的时候设置了密码，我也不清楚是因为设置了密码访问不成功还是因为不一致导致的）</p><p><em>git config —global user.name “用户名”</em></p><p><em>git config —global user.email “你的邮箱”</em></p><p>设置完毕之后，执行命令<em>ssh-keygen -t rsa -C “github注册邮箱”</em>，执行完成后，会生成一个.ssh文件夹，里面的id_rsa.pub文件内容就是秘钥，那么我们就进入ssh文件夹打开该文件后复制它的内容。进入GitHub个人账户的settings-&gt;SSH and GPG keys，将SSH密钥添加到自己的仓库设置中。</p><p>接着在hexo deploy时如果出现<br><code>The authenticity of host &#39;github.com (192.30.253.112)&#39; can&#39;t be established.</code><br><code>RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</code><br><code>Are you sure you want to continue connecting (yes/no)?</code></p><p>输入yes回车即可。</p><h2 id="文章撰写的一些基础知识"><a href="#文章撰写的一些基础知识" class="headerlink" title="文章撰写的一些基础知识"></a>文章撰写的一些基础知识</h2><p>新建一篇文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;title&quot;</span><br></pre></td></tr></table></figure><p>部署发布：</p><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong></p><blockquote><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p></blockquote><h3 id="粗体、斜体、删除线和下划线"><a href="#粗体、斜体、删除线和下划线" class="headerlink" title="粗体、斜体、删除线和下划线"></a>粗体、斜体、删除线和下划线</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong></p><blockquote><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p></blockquote><h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 文字引用</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong> </p><blockquote><p>Ctrl+Shift+Q</p></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`行内代码`</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong></p><blockquote><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p></blockquote><h3 id="公式块"><a href="#公式块" class="headerlink" title="公式块"></a>公式块</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br><span class="line">123</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong> </p><blockquote><p>Ctrl+Shift+M</p></blockquote><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong></p><blockquote><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p></blockquote><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown 语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><p><strong>Typora 快捷键：</strong> Ctrl+T</p><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><strong>Markdown语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 &quot;链接描述&quot;)</span><br><span class="line">例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure><p><strong>Typora快捷键：</strong> </p><blockquote><p> Ctrl+K</p></blockquote><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><strong>Markdown语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p>Typora快捷键： </p><blockquote><p>Ctrl+Shift+I</p></blockquote><p>说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><p>将 站点配置文件 中的 <em>post_asset_folder</em> 选项的值设置为 <em>true</em></p><p>在站点文件夹中打开 <em>git bash</em>，输入命令 <em>npm install hexo-asset-image —save</em> 安装插件</p><p>这样，当使用 hexo new title 创建文章时，将同时在 <em>source/_post</em> 文件夹中生成一个与 <em>title</em> 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![示例图片](title/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p> 添加图片</p><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><h3 id="模板设置"><a href="#模板设置" class="headerlink" title="模板设置"></a>模板设置</h3><p>当我们使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化。</p><p>换言之，<code>/scaffolds/post.md</code> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: </span><br><span class="line">categories:</span><br></pre></td></tr></table></figure><h3 id="头部设置"><a href="#头部设置" class="headerlink" title="头部设置"></a>头部设置</h3><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误。</p><h3 id="首页显示"><a href="#首页显示" class="headerlink" title="首页显示"></a>首页显示</h3><p>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p><p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p><p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，表示只会显示标志前面的内容</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;换了电脑以后一直没有鼓起勇气重新安装各种软件（怕麻烦本人哈哈哈），阿里云的email提醒我域名该续费了，续完费发现自己又把之前的操作什么的忘
      
    
    </summary>
    
    
      <category term="博客" scheme="http://tracywoo.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://tracywoo.cn/tags/hexo/"/>
    
      <category term="git" scheme="http://tracywoo.cn/tags/git/"/>
    
      <category term="node" scheme="http://tracywoo.cn/tags/node/"/>
    
      <category term="markdown" scheme="http://tracywoo.cn/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>NSGA2</title>
    <link href="http://tracywoo.cn/2020/03/18/NSGA2/"/>
    <id>http://tracywoo.cn/2020/03/18/NSGA2/</id>
    <published>2020-03-18T02:59:08.000Z</published>
    <updated>2020-03-18T04:24:58.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>NSGA2</strong>(Non-dominated sorting in genetic algorithm2)</p><p>相比较NSGA从以下三个部分进行了改善：保留了最优个体；不用设置共享参数；构造Pareto最优解集的时间复杂度有所降低。</p><p><strong>算法的时间开销由三部分组成</strong>：</p><p>构造分类子集(Non-dominated sort) O(r(2N)^2)</p><p>计算聚集距离</p><p>构造偏序集：个体之间的偏序<img src="//tracywoo.cn/2020/03/18/NSGA2/e6.PNG" alt="e6"> </p><h2 id="非支配集的构造方法"><a href="#非支配集的构造方法" class="headerlink" title="非支配集的构造方法"></a>非支配集的构造方法</h2><p>为每一个个体p设置两个性质：np记录p支配个体的数目，sp记录被p支配的个体的集合。</p><p><img src="//tracywoo.cn/2020/03/18/NSGA2/e1.PNG" alt="e1"></p><p>通过一个二重循环计算每个个体的np和sp，则</p><p><img src="//tracywoo.cn/2020/03/18/NSGA2/e2.PNG" alt="e2"></p><p><img src="//tracywoo.cn/2020/03/18/NSGA2/e3.PNG" alt="e3"></p><p><strong>构造非支配集的过程</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">nondominated-<span class="built_in">sort</span>(P)</span><br><span class="line">任意Pop中的个体p，np=0,Sp为空 //初始化</span><br><span class="line"><span class="keyword">for</span> p in Pop</span><br><span class="line"><span class="keyword">for</span> q in Pop</span><br><span class="line">    <span class="keyword">if</span> p支配q</span><br><span class="line">         Sp = [ Sp q ];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> q支配p</span><br><span class="line">        np = np + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">     <span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line">     <span class="keyword">if</span> np = <span class="number">0</span></span><br><span class="line">     P1 = [P1 , np];</span><br><span class="line">     <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!Pi)</span><br><span class="line">H = [];</span><br><span class="line"><span class="keyword">for</span> p in Pi</span><br><span class="line"><span class="keyword">for</span> q in Sp</span><br><span class="line">nq = nq - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> nq == <span class="number">0</span></span><br><span class="line">H = [H q];</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line"><span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line">Pi = H;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span></span><br></pre></td></tr></table></figure><h2 id="保持解群体分布性和多样性的方法"><a href="#保持解群体分布性和多样性的方法" class="headerlink" title="保持解群体分布性和多样性的方法"></a>保持解群体分布性和多样性的方法</h2><p>产生新群体时，通常将优秀且聚集度比较小的个体保留参与下一代进化，聚集密度小的个体聚集距离反而大。</p><p>本算法中引入了拥挤距离。</p><p>对于一个双目标的算法</p><p><img src="//tracywoo.cn/2020/03/18/NSGA2/e4.PNG" alt="e4"></p><p><img src="//tracywoo.cn/2020/03/18/NSGA2/e5.jpg" alt="e5"></p><p><strong>计算个体之间的拥挤距离</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">crowding-distance-assignment(P)</span><br><span class="line">N = |P|</span><br><span class="line"><span class="keyword">for</span> each <span class="built_in">i</span></span><br><span class="line">P_distance = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> each objective m</span><br><span class="line">P = <span class="built_in">sort</span>(P,m);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span> to (N<span class="number">-1</span>)</span><br><span class="line">P[<span class="built_in">i</span>]_distance = P[<span class="built_in">i</span>]_distance + (P[<span class="built_in">i</span>+<span class="number">1</span>]_distance.m-P[<span class="built_in">i</span><span class="number">-1</span>]_distance.m)</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">for</span></span><br><span class="line">P[<span class="number">0</span>]_distance = P[N]_distance = 无穷;</span><br></pre></td></tr></table></figure><p><strong>NSGA2</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">初始化随机产生一个初始群体 P_0</span><br><span class="line">Q_0 = make_new_pop(P_0);</span><br><span class="line">t = <span class="number">0</span>;</span><br><span class="line">R_t = R_t + Q_t;</span><br><span class="line">F = nondominated-<span class="built_in">sort</span>(R_t);</span><br><span class="line">P_t+<span class="number">1</span> = [] and <span class="built_in">i</span> = <span class="number">1</span>;</span><br><span class="line">Until(|P_t+<span class="number">1</span>|+|F_i|&lt;=N)</span><br><span class="line">P_t=<span class="number">1</span> = p_t+<span class="number">1</span> + F_i;</span><br><span class="line"><span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">crowding-distance-assignment(F_i);</span><br><span class="line"><span class="built_in">sort</span>(F_i,&gt;);</span><br><span class="line">P_t+<span class="number">1</span> = P_t+<span class="number">1</span> + F_i(<span class="number">1</span>:N-|P_t+<span class="number">1</span>|);</span><br><span class="line">Q_t+<span class="number">1</span> = make_new_pop(P_t+<span class="number">1</span>);</span><br><span class="line">t = t + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;NSGA2&lt;/strong&gt;(Non-dominated sorting in genetic algorithm2)&lt;/p&gt;
&lt;p&gt;相比较NSGA从以下三个部分进行了改善：保留了最优个体；不用设置共享参数；构造Pareto最优解集的时间复杂度有所降低。&lt;/
      
    
    </summary>
    
    
    
      <category term="MOEA" scheme="http://tracywoo.cn/tags/MOEA/"/>
    
  </entry>
  
  <entry>
    <title>多目标进化计算</title>
    <link href="http://tracywoo.cn/2020/03/18/%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E8%AE%A1%E7%AE%97/"/>
    <id>http://tracywoo.cn/2020/03/18/%E5%A4%9A%E7%9B%AE%E6%A0%87%E8%BF%9B%E5%8C%96%E8%AE%A1%E7%AE%97/</id>
    <published>2020-03-18T02:02:02.000Z</published>
    <updated>2020-03-18T03:02:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Pareto改善"><a href="#Pareto改善" class="headerlink" title="Pareto改善"></a>Pareto改善</h4><p>给定固有的一群人和可分配的资源，从一种分配的状态到另一种状态的变化中，在没有人变坏的情况下，使得至少一个人变得更好。</p><p>也就是说资源分配的理想状态是不可能再有更多的Pareto改善的状态。</p><h4 id="Pareto解"><a href="#Pareto解" class="headerlink" title="Pareto解"></a>Pareto解</h4><p>在有多个目标时，由于存在目标之间的冲突无法进行比较的情况，一个解在某个目标上是最好的，在其他目标上可能是最差的，一组目标函数最优解的集合是Pareto最优集，形成的曲面为Pareto前沿面。</p><h2 id="进化计算"><a href="#进化计算" class="headerlink" title="进化计算"></a>进化计算</h2><p>达尔文在进化论中提出了这样一个概念——<u>物竞天择，适者生存</u>。</p><p>进化计算是基于群体的启发式搜索优化问题。</p><h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p>约翰·霍兰德提出了遗传算法，是进化算法的一种。</p><p>Step1:     ① 种群中个体随机初始化；</p><p>​               ② 每个个体通过评价得到一个适应度值；</p><p>​               ③ 适应度大的个体有更大的概率留下来；</p><p>​               ④适应度大的个体交叉变异产生新的个体；</p><p>Step2：不断迭代②~④</p><p>经过足够多次的迭代后，最终能够得到好的解。</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/GA.png" alt="GA"></p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>编码具有三个特点：完备性，健全性，非冗余性。</p><p>每个特征都与编码结果一一对应。</p><h4 id="适应度评价"><a href="#适应度评价" class="headerlink" title="适应度评价"></a>适应度评价</h4><p>位串（个体）-&gt;适应度-&gt;目标函数。</p><p>适应度是用于评价目标函数的一个自定义的函数，优化的方向为适应度增大的方向，对于最小化问题：</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/e1.PNG" alt="e1"></p><p>其中C_max可以是自己设定的值或者是当代的最大值。</p><p>相应的，对于最大化问题：</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/e2.PNG" alt="e2"></p><h4 id="遗传操作"><a href="#遗传操作" class="headerlink" title="遗传操作"></a>遗传操作</h4><h5 id="选择-selection-复制-reproduction"><a href="#选择-selection-复制-reproduction" class="headerlink" title="选择(selection)/复制(reproduction)"></a>选择(selection)/复制(reproduction)</h5><p>选择算子：选择适应度高的个体放入交配池。</p><h5 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h5><p>模仿有性繁殖中的基因重组</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/pc.png" alt="pc">为交叉概率，随机选择k个交叉位置，根据<img src="//tracywoo.cn/2020/03/18/多目标进化计算/pc.png" alt="pc">实行交叉操作。</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/pc.png" alt="pc">一般比较大，比如0.8.</p><h5 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h5><p>模拟有性繁殖中的基因突变。</p><p>按<img src="//tracywoo.cn/2020/03/18/多目标进化计算/pm.PNG" alt="pm">反转某位的二进制字符，一般比较小，比如0.005.</p><h2 id="多目标进化"><a href="#多目标进化" class="headerlink" title="多目标进化"></a>多目标进化</h2><h4 id="多目标进化-1"><a href="#多目标进化-1" class="headerlink" title="多目标进化"></a>多目标进化</h4><p>一种常见的优化策略的问题。</p><h4 id="凸空间与凹空间"><a href="#凸空间与凹空间" class="headerlink" title="凸空间与凹空间"></a>凸空间与凹空间</h4><p><strong>凸集(convexity)</strong>:一个集合S的任意两个点的连线上的点仍为S中的点。</p><p><strong>凹集</strong>：与凸集的定义相反。</p><h4 id="基于Pareto多目标进化算法的一般框架"><a href="#基于Pareto多目标进化算法的一般框架" class="headerlink" title="基于Pareto多目标进化算法的一般框架"></a>基于Pareto多目标进化算法的一般框架</h4><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/MOEA.png" alt="moea"></p><h4 id="多目标Pareto最优解集构造方法"><a href="#多目标Pareto最优解集构造方法" class="headerlink" title="多目标Pareto最优解集构造方法"></a>多目标Pareto最优解集构造方法</h4><h5 id="简单方法"><a href="#简单方法" class="headerlink" title="简单方法"></a>简单方法</h5><p>通过个体与个体的比较，依次删除被支配的个体。</p><h5 id="庄家法"><a href="#庄家法" class="headerlink" title="庄家法"></a>庄家法</h5><p>初始化创造集Q，每取出一个个体，就在Q中去除这个个体，去除由这个个体支配的所有个体，若这个个体不被任何一个个体支配，则把它放入NDset。</p><h5 id="擂台法"><a href="#擂台法" class="headerlink" title="擂台法"></a>擂台法</h5><p>每一轮选出一个擂主，与其他个体进行比较，败者出局，胜者称为新的擂主。</p><p>注意需要保留与前一个擂主不相关的个体的比较。</p><h5 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h5><h5 id="快速排序方法"><a href="#快速排序方法" class="headerlink" title="快速排序方法"></a>快速排序方法</h5><p><strong>个体之间的关系</strong>：若x和y不存在支配关系，那么如果y支配x，那么x支配z或者x和z不相关。</p><p>快速排序中使用到了一个符号<img src="//tracywoo.cn/2020/03/18/多目标进化计算/bxg.PNG" alt="bxg">，按照这个关系进行快速排序：x支配y或者x与y不相关。</p><p>每一次拿出一个个体，将群体分为两个部分，一部分是被个体支配的个体，另一部分是由个体支配的个体，被个体支配的个体被清除，进入下一轮比较。</p><h4 id="多目标群体的分布性"><a href="#多目标群体的分布性" class="headerlink" title="多目标群体的分布性"></a>多目标群体的分布性</h4><p><strong>小生境</strong>：把特定环境中有共同特性的组织称为物种。（物以类聚）</p><p><strong>基于预选择机制(preselection)</strong>:若子代的适应度高于父代的适应度，那么可以用子代代替父代。</p><p><strong>基于排挤机制(crowding)</strong>:设置排挤因子CF，选择规模为1/CF的子集为一个排挤子集，计算相似性，用新个体代替相似个体。</p><p><strong>基于共享机制(sharing):</strong></p><p>定义共享函数<img src="//tracywoo.cn/2020/03/18/多目标进化计算/share.PNG" alt="share">，其中的d(i,j)为个体i和个体j的相似度。</p><p>则个体i的共享适应度为<img src="//tracywoo.cn/2020/03/18/多目标进化计算/sf.PNG" alt="sf"></p><p>设置共享半径，只计算共享半径以内的个体相似程度</p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/sr.PNG" alt="sr"></p><h5 id="多目标进化中的适应度"><a href="#多目标进化中的适应度" class="headerlink" title="多目标进化中的适应度"></a>多目标进化中的适应度</h5><p><strong>目标函数组合法</strong></p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/11.PNG" alt="11"></p><p><strong>简单支配关系法</strong></p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/s2.PNG" alt="s2"></p><p><strong>复合支配关系法</strong></p><p><img src="//tracywoo.cn/2020/03/18/多目标进化计算/c3.PNG" alt="c3"></p><h5 id="用聚类方法保持分布性"><a href="#用聚类方法保持分布性" class="headerlink" title="用聚类方法保持分布性"></a>用聚类方法保持分布性</h5><p>个体的相似度计算可以分为</p><h6 id="实数编码"><a href="#实数编码" class="headerlink" title="实数编码"></a>实数编码</h6><p><strong>欧几里得距离</strong>：向量各位差的平方和的开方。</p><p><strong>曼哈顿距离</strong>：向量各位差的绝对值之和。</p><p><strong>明考斯基距离</strong>：向量各位差的q次方和的开q次方。</p><h6 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h6><p><strong>海明距离</strong>：向量各位差的平方和的开方。</p><h6 id="符号编码"><a href="#符号编码" class="headerlink" title="符号编码"></a>符号编码</h6><p>一般用asc2表示各位。</p><h5 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h5><h5 id="基于中心点"><a href="#基于中心点" class="headerlink" title="基于中心点"></a>基于中心点</h5><p>将群体分为m类，选择m个个体为初始中心点</p><p>① 计算选出的点与其他点的距离</p><p>② 将与选出的点最相似的个体指派到相应的类中，计算评价函数的值<img src="//tracywoo.cn/2020/03/18/多目标进化计算/E.PNG" alt="E"></p><p>③ 分别在各类中随机选择一个非中心点重复①②，计算E’，若优于E，则代替中心点，重新调整类。</p><h5 id="类距离"><a href="#类距离" class="headerlink" title="类距离"></a>类距离</h5><p>把n个个体当成n个类，将具有最大相似度的个体聚集到同一类。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Pareto改善&quot;&gt;&lt;a href=&quot;#Pareto改善&quot; class=&quot;headerlink&quot; title=&quot;Pareto改善&quot;&gt;&lt;/a&gt;Pareto改善&lt;/h4&gt;&lt;p&gt;给定固有的一群人和可分配的资源，从一种分配的状态到另一种状态的变化中，在没有人变坏的情况下，
      
    
    </summary>
    
    
    
      <category term="MOEA" scheme="http://tracywoo.cn/tags/MOEA/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo和GitHub创建属于自己的博客吧</title>
    <link href="http://tracywoo.cn/2020/03/16/%E7%94%A8Hexo%E5%92%8CGitHub%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/"/>
    <id>http://tracywoo.cn/2020/03/16/%E7%94%A8Hexo%E5%92%8CGitHub%E5%88%9B%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%90%A7/</id>
    <published>2020-03-16T08:50:57.000Z</published>
    <updated>2020-03-18T02:38:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于很久没有使用自己的博客，已经忘记了当初的搭建过程和<code>hexo</code>的指令，用这篇博客来温习一下自己搭建博客的过程和遇到的问题。  </p><p>在写博客的文件右击鼠标-&gt;<code>git bash here</code>，使用<code>hexo</code>指令的时候出现了指令不存在的情况。可以通过以下三个步骤进行排查：  </p><p><code>node -v</code></p><p><code>npm -v</code></p><p>检查本机的环境变量中的系统变量中的path是否包含了与<code>_config.yml</code>在同一个目录的<code>node_modeles</code>文件夹中的.bin文件夹。</p><p>我的电脑里的文件目录是：<code>D:\blog\node_modules\.bin</code></p><p>好了，下面说一下安装过程：</p><h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><p>下载git，<a href="https://git-scm.com/download/win(到此页面后，稍微等一下会有下载弹框" target="_blank" rel="noopener">https://git-scm.com/download/win(到此页面后，稍微等一下会有下载弹框</a>)</p><h1 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h1><p>下载node.js：</p><p>下载方式一：<a href="http://nodejs.org/download/" target="_blank" rel="noopener">http://nodejs.org/download/</a></p><p>下载方式二：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><p>下载方式三：<a href="http://download.csdn.net/download/ainuser/9952074" target="_blank" rel="noopener">http://download.csdn.net/download/ainuser/9952074</a></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>安装Hexo，在自己要写博客的文件夹右击打开git命令框，输入npm install -g hexo</p><p>hexo初始化：hexo init</p><p>启动服务(npm install —&gt;hexo server —&gt;hexo clean —&gt;hexo generate —&gt;hexo deploy)</p><p><strong><em>重新部署更新</em></strong></p><p><strong><em>下面这条命令会经常用到</em></strong></p><p><strong>(</strong>hexo clean —&gt;hexo generate —&gt;hexo deploy)</p><p>对于github的部分，可以参照这个博客链接：</p><p><a href="https://blog.csdn.net/AinUser/article/details/77609180" target="_blank" rel="noopener">https://blog.csdn.net/AinUser/article/details/77609180</a></p><p>hexo主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>hexo生成博文插入图片：<a href="https://blog.csdn.net/qq_37497322/article/details/80628713" target="_blank" rel="noopener">https://blog.csdn.net/qq_37497322/article/details/80628713</a></p><p>next主题个性化设置：<a href="https://www.cnblogs.com/liziczh/p/9318656.html" target="_blank" rel="noopener">https://www.cnblogs.com/liziczh/p/9318656.html</a></p><p><a href="https://www.cnblogs.com/fengxiongZz/p/7707568.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707568.html</a></p><p><a href="https://www.cnblogs.com/liziczh/p/9318652.html" target="_blank" rel="noopener">https://www.cnblogs.com/liziczh/p/9318652.html</a></p><p>我的Hexo主题：<a href="https://github.com/fi3ework/hexo-theme-archer/blob/master/README.md" target="_blank" rel="noopener">https://github.com/fi3ework/hexo-theme-archer/blob/master/README.md</a></p><h2 id="遇到的一些问题（持续更新）"><a href="#遇到的一些问题（持续更新）" class="headerlink" title="遇到的一些问题（持续更新）"></a>遇到的一些问题（持续更新）</h2><p><strong>插入的图片无法显示</strong></p><p>设置图片路径时用到的斜杠为/</p><p><strong>博文发布以后出现can not read a block mapping entry; a multiline key may not be an implicit key …并且无法在页面上显示:</strong></p><p>设置tag的时候，需要谨记加一个空格</p><p><strong>忘记了新建博客的指令</strong></p><p>hexo new “title”</p><p><strong>不要把<code>{</code>和<code>{</code>放在一起写</strong></p><p>中间加一个空格</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于很久没有使用自己的博客，已经忘记了当初的搭建过程和&lt;code&gt;hexo&lt;/code&gt;的指令，用这篇博客来温习一下自己搭建博客的过程和遇到的问题。  &lt;/p&gt;
&lt;p&gt;在写博客的文件右击鼠标-&amp;gt;&lt;code&gt;git bash here&lt;/code&gt;，使用&lt;code&gt;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://tracywoo.cn/2019/08/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://tracywoo.cn/2019/08/29/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2019-08-29T07:04:13.000Z</published>
    <updated>2020-03-18T01:58:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><strong>排序算法的稳定性</strong>：两个相等的数据前后顺序不发生改变。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>每次排序能够确定最后一个元素的位置（将最大的元素移到最后一个位置）<br><strong>算法思想</strong> </p><p><img src="//tracywoo.cn/2019/08/29/排序算法/冒泡排序.png" alt="冒泡排序原理"></p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (A[j] &gt; A[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[j];</span><br><span class="line">A[j] = A[j + <span class="number">1</span>];</span><br><span class="line">A[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">flag = <span class="number">1</span>;<span class="comment">//进行了交换</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//当某一轮没有交换的时候，说明顺序表已经有序了</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进</strong></p><p>① 传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中<strong>进行正向和反向两遍冒泡</strong>的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。</p><p>② 设置一标志性变量pos, 用于记录每趟排序中<strong>最后一次进行交换的位置</strong>。由于<strong>pos位置之后的记录均已交换到位</strong>,故在进行下一趟排序时只要扫描到pos位置即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_1</span><span class="params">(<span class="keyword">int</span> r[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = n - <span class="number">1</span>;  <span class="comment">//初始时,最后位置保持不变  </span></span><br><span class="line"><span class="keyword">while</span> (i&gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//每趟开始时,无记录交换  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; i; j++)</span><br><span class="line"><span class="keyword">if</span> (r[j]&gt; r[j + <span class="number">1</span>]) &#123;</span><br><span class="line">pos = j; <span class="comment">//记录交换的位置   </span></span><br><span class="line"><span class="keyword">int</span> tmp = r[j]; r[j] = r[j + <span class="number">1</span>]; r[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">i = pos; <span class="comment">//为下一趟排序作准备  </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><p>类似于抓牌，每次都认为第i个元素之前的元素全部就位。<br><strong>基本思想</strong><br>将一个记录插入到已排序好的有序表中，从而得到一个新记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。<br><strong>要点</strong>：设立<strong>哨兵</strong>，作为临时存储和判断数组边界之用。<br><strong>直接插入排序示例：</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/简单插入排序.png" alt="简单插入排序原理"></p><p><strong>直接插入代码示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_Sort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[i];</span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>&amp;&amp;A[j<span class="number">-1</span>]&gt;temp; j--) &#123;<span class="comment">//！！条件很重要</span></span><br><span class="line">A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">A[j] = temp;</span><br><span class="line">Print(A, n, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span> &#125;;</span><br><span class="line">Insert_Sort(a, <span class="number">8</span>);           <span class="comment">//直接插入排序  </span></span><br><span class="line">Print(a, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是1959 年由D.L.Shell 提出来的，相对直接排序有较大的改进。希尔排序又叫缩小增量排序可以看成是插入排序的升级版本。</p><p><strong>基本思想：</strong><br>先将整个待排序的记录序列分割成为<strong>若干子序列分别进行直接插入排序</strong>，待整个序列中的记录“基本有序”时，再对<strong>全体记录</strong>进行依次直接插入排序。</p><p><strong>操作方法</strong></p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><p><strong>希尔排序的示例</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/希尔排序.png" alt="希尔排序"></p><p><strong>算法实现：</strong></p><ul><li><p>我们简单处理增量序列：增量序列d = {n/2 ,n/4, n/8 …..1} n为要排序数的个数</p></li><li><p>即：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。</p></li></ul><p><strong>代码示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert_Sort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n,<span class="keyword">int</span> dk)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dk; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[i];</span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span>&amp;&amp;A[j-dk]&gt;temp; j-=dk) &#123;<span class="comment">//！！条件很重要</span></span><br><span class="line">A[j] = A[j - dk];</span><br><span class="line">&#125;</span><br><span class="line">A[j] = temp;</span><br><span class="line">Print(A, n, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dk = n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (dk&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">ShellInsert_Sort(A, n, dk);</span><br><span class="line">dk /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span> &#125;;</span><br><span class="line">Shell_Sort(a, <span class="number">8</span>);           <span class="comment">//直接插入排序  </span></span><br><span class="line">Print(a, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/希尔排序结果.png" alt="希尔排序结果"></p><p><strong>总结</strong></p><p>希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个<strong>不稳定</strong>的排序方法。</p><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>满足条件：i<j, a[i]>A[j]</j,></p><p>任意N个不同元素的组成的序列平均有N(N-1)/4个逆序对，所以任意建立在交换相邻两元素基础上的排序算法的时间复杂度为$ \Omega(N^{2})$</p><p>因此目标：每次交换能消掉好几个逆序对。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>堆排序</p><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。<br><strong>基本思想：</strong><br><strong>堆的定义</strong>如下：具有n个元素的序列（k1,k2,…,kn),当且仅当满足：</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/堆.png" alt="堆"></p><script type="math/tex; mode=display"></script><p>时称之为堆，即当子女节点均小于（/大于）父结点的时候，可以构成最大（/小）堆，由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。</p><p>若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。如：<br>（a）大顶堆序列：（96, 83,27,38,11,09)<br>（b）小顶堆序列：（12，36，24，85，47，30，53，91）</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/堆2.png" alt="堆2"></p><p>初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树），<strong>调整它们的存储序，使之成为一个堆，将堆顶元素输出</strong>，得到n 个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n 个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为堆排序。</p><p>因此，实现堆排序需解决两个问题：<br><strong>① 如何将n 个待排序的数建成堆；</strong><br><strong>建堆方法：</strong>对初始序列建堆的过程，就是一个反复进行筛选的过程。<br>n 个结点的完全二叉树，则最后一个结点是第<img src="//tracywoo.cn/2019/08/29/排序算法/1.png" alt="1"> 个结点的子树；筛选从第 <img src="//tracywoo.cn/2019/08/29/排序算法/2.png" alt="2">个结点为根的子树开始，该子树成为堆；之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。</p><p>如图为建最小堆初始过程：无序序列：（49，38，65，97，76，13，27，49）</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/3.png" alt="3"></p><p><strong>② 输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</strong><br>设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。<br>将根结点与左、右子树中较小元素的进行交换。<br>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 （2）.<br>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 （2）.<br>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。<br>称这个自根结点到叶子结点的调整过程为筛选。如图：</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/4.png" alt="4"></p><p><strong>代码示例</strong></p><p>从算法描述来看，堆排序需要两个过程，一是建立堆，二是<strong>堆顶与堆的最后一个元素交换位置</strong>。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">建立一个大顶堆，每次把最大的元素放到最后</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 已知H[s…m]除了H[s] 外均满足堆的定义</span></span><br><span class="line"><span class="comment">* 调整H[s],使其成为大顶堆.即将对第s个结点为根的子树筛选,</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param H是待调整的堆数组</span></span><br><span class="line"><span class="comment">* @param s是待调整的数组元素的位置</span></span><br><span class="line"><span class="comment">* @param length是数组的长度</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> s, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = H[s];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">2</span> * s + <span class="number">1</span>; <span class="comment">//左孩子结点的位置。(i+1 为当前调整结点的右孩子结点的位置)  </span></span><br><span class="line"><span class="keyword">while</span> (child &lt; length) &#123;<span class="comment">//当树是完美二叉树的时候，是没有左孩子的，所以要对于元素进行判断</span></span><br><span class="line"><span class="keyword">if</span> (child + <span class="number">1</span> &lt;length &amp;&amp; H[child]&lt;H[child + <span class="number">1</span>]) &#123; <span class="comment">// 如果右孩子大于左孩子(找到比当前待调整结点大的孩子结点)  </span></span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (H[s]&lt;H[child]) &#123;  <span class="comment">// 如果较大的子结点大于父结点  </span></span><br><span class="line">H[s] = H[child]; <span class="comment">// 那么把较大的子结点往上移动，替换它的父结点  </span></span><br><span class="line">s = child;       <span class="comment">// 重新设置s ,即待调整的下一个结点的位置  </span></span><br><span class="line">child = <span class="number">2</span> * s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;            <span class="comment">// 如果当前待调整结点大于它的左右孩子，则不需要调整，直接退出  </span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">H[s] = tmp;         <span class="comment">// 当前待调整的结点放到比其大的孩子结点位置上  </span></span><br><span class="line">&#125;</span><br><span class="line">print(H, length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 初始堆进行调整</span></span><br><span class="line"><span class="comment">* 将H[0..length-1]建成堆</span></span><br><span class="line"><span class="comment">* 调整完之后第一个元素是序列的最小的元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildingHeap</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//最后一个有孩子的节点的位置 i=  (length -1) / 2  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (length - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"建立堆:"</span>;</span><br><span class="line">HeapAdjust(H, i, length);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 堆排序算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> H[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始堆  </span></span><br><span class="line">BuildingHeap(H, length);</span><br><span class="line"><span class="comment">//从最后一个元素开始对序列进行调整  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//交换堆顶元素H[0]和堆中最后一个元素  </span></span><br><span class="line"><span class="keyword">int</span> temp = H[i]; H[i] = H[<span class="number">0</span>]; H[<span class="number">0</span>] = temp;</span><br><span class="line"><span class="comment">//每次交换堆顶元素和堆中最后一个元素之后，都要对堆进行调整  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"调整堆:"</span>;</span><br><span class="line">HeapAdjust(H, <span class="number">0</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">10</span>] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"初始值："</span>;</span><br><span class="line">print(H, <span class="number">10</span>);</span><br><span class="line">HeapSort(H, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//selectSort(a, 8);  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"结果："</span>;</span><br><span class="line">print(H, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/5.png" alt="5"></p><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><p><strong>基本思想：</strong><br>在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。<br>简单选择排序的示例</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/简单选择排序.png" alt="简单选择排序"></p><p><strong>操作方法：</strong><br>第一趟，从n 个记录中找出关键码最小的记录与第一个记录交换；<br>第二趟，从第二个记录开始的n-1 个记录中再选出关键码最小的记录与第二个记录交换；<br>以此类推…..<br>第i 趟，则从第i 个记录开始的n-i+1 个记录中选出关键码最小的记录与第i 个记录交换，<br>直到整个序列按关键码有序。<br><strong>算法实现</strong><br>寻找第i个元素之后最小的元素<br>交换位置</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; A[j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到i位置之后最小的元素，放到当前某个位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Selectminkey</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> k = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span> (A[k] &gt; A[j])</span><br><span class="line">k = j;</span><br><span class="line"><span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="keyword">int</span> *A,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> k= Selectminkey(A, n, i);</span><br><span class="line"><span class="keyword">if</span> (k != i) &#123;</span><br><span class="line"><span class="comment">//交换第i个和第maxidex个</span></span><br><span class="line"><span class="keyword">int</span> tmp = A[k];</span><br><span class="line">A[k] = A[i];</span><br><span class="line">A[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">Print(A, <span class="number">8</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span> &#125;;</span><br><span class="line">Select_Sort(a, <span class="number">8</span>);           <span class="comment">//直接插入排序  </span></span><br><span class="line">Print(a, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/简单选择结果.png" alt="简单选择结果"></p><p><strong>改进的选择排序——二元选择排序</strong></p><p>每次循环确定最大值和最小值的位置。</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>基本思想：</strong><br>选择一个基准元素,通常选择第一个元素或者最后一个元素,<br>通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。<br>此时基准元素在其排好序后的正确位置<br>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。<br><strong>坏处</strong><br>调用递归，对于小规模数据浪费了时间。<br>快速排序的示例：<br><strong>一趟排序的过程：</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/快排.png" alt="快排"></p><p><strong>排序的全过程：</strong></p><p><img src="//tracywoo.cn/2019/08/29/排序算法/kp过程.png" alt="kp过程"></p><p><strong>评价</strong></p><p>快速排序是通常被认为在同数量级<strong>（O(nlog2n)）</strong>的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。对于大规模的随机数据表现出色。每一次调整后，主元的位置都会放在正确的位置上。</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/6.png" alt="6"></p><p><strong>最好情况：每次正好中分。</strong><br>选主元：最坏情况是序列本来就是有序的，O(N^2)<br>取头、中、尾的中位数。</p><p><img src="//tracywoo.cn/2019/08/29/排序算法/7.png" alt="7"></p><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[j] &lt;&lt; <span class="string">"  "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = *a;<span class="comment">//int *temp=*a会报错</span></span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Median3</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (A[left] &gt; A[center]) &#123;</span><br><span class="line">swap(&amp;A[left], &amp;A[center]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[right] &lt; A[left]) &#123;</span><br><span class="line">swap(&amp;A[right], &amp;A[left]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A[right] &lt; A[center]) &#123;</span><br><span class="line">swap(&amp;A[right], &amp;A[center]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*A[left]&lt;=A[center]&lt;=A[right]*/</span></span><br><span class="line"><span class="comment">//问题：当right&lt;0的时候，地址会泄露</span></span><br><span class="line">swap(&amp;A[center], &amp;A[right - <span class="number">1</span>]);<span class="comment">/*将pivot藏到右边*/</span></span><br><span class="line"><span class="keyword">return</span> A[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = Median3(A, left, right);</span><br><span class="line"><span class="keyword">int</span> low = left, high = right - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">while</span> (A[++low] &lt; pivot) &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> (A[--high] &gt; pivot) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">swap(&amp;A[low], &amp;A[high]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;A[low], &amp;A[right - <span class="number">1</span>]);<span class="comment">//把主元放到正确的位置</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pivot &lt;&lt; <span class="string">":"</span>;</span><br><span class="line">print(A, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (low&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(left&lt;=low<span class="number">-1</span>)</span><br><span class="line">Quicksort(A, left, low - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (low+<span class="number">1</span> &lt;= right)</span><br><span class="line">Quicksort(A, low + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_sort</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">Quicksort(A, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> H[<span class="number">10</span>] = &#123; <span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"初始状态:"</span>;</span><br><span class="line">print(H, <span class="number">10</span>);</span><br><span class="line">Quick_sort(H, <span class="number">10</span>);</span><br><span class="line">print(H, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br><img src="//tracywoo.cn/2019/08/29/排序算法/快排re.png" alt="找不到文件"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;排序算法的稳定性&lt;/strong&gt;：两个相等的数据前后顺序不发生改变。&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;
      
    
    </summary>
    
    
    
      <category term="算法" scheme="http://tracywoo.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello,Hexo</title>
    <link href="http://tracywoo.cn/2019/08/28/Hello-Hexo/"/>
    <id>http://tracywoo.cn/2019/08/28/Hello-Hexo/</id>
    <published>2019-08-28T08:18:11.000Z</published>
    <updated>2019-08-29T07:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019-08-28"><a href="#2019-08-28" class="headerlink" title="2019/08/28"></a>2019/08/28</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"hello,world!\n"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019-08-28&quot;&gt;&lt;a href=&quot;#2019-08-28&quot; class=&quot;headerlink&quot; title=&quot;2019/08/28&quot;&gt;&lt;/a&gt;2019/08/28&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
    
      <category term="others" scheme="http://tracywoo.cn/tags/others/"/>
    
  </entry>
  
</feed>
